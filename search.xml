<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Environment Configuration for Yolo-darknet</title>
    <url>/2018/02/20/Environment-Configuration-for-Yolo-darknet/</url>
    <content><![CDATA[<blockquote>
<p>Just do it.<br>Just do something new and do it yourself.</p>
</blockquote>
<p>记录一些关于yolo-darknet环境配置踩过的坑。<br>能力有限，但求指点，欢迎交流。</p>
<a id="more"></a>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li>OS: Ubuntu 16.04 LTS</li>
<li>PC: ASUS K550J (EFI enable)</li>
<li>GPU: GTX950M</li>
<li>CPU: i5-4200H</li>
<li>RAM: 4G</li>
<li>DISK: 1T HDD (no SSD) </li>
</ul>
<h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><h3 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h3><ol>
<li>用UltraISO把iso文件烧到你的U盘，<strong>进BIOS打开EFI引导，并选择EFI模式下的U盘为第一引导项</strong></li>
<li>安装Ubuntu到一个空白分区（可以通过分区压缩获得，如果是全新电脑就直接开始分区了）：<ul>
<li><strong>注意根据提示划分那块bios efi的小分区，几十K即可</strong>；</li>
<li><strong>划分swap交换分区，一般是你内存大小的3倍大，划在主分区后面</strong>；</li>
<li>剩下的划给主分区；</li>
<li>选择安装启动器到<strong>Windows使用的那个EFI启动分区</strong>。</li>
</ul>
</li>
<li>进入分区界面前有几个选项要注意：<ul>
<li>让你顺带安装更新的那个，<strong>不要勾选</strong>，更新的源大多自动匹配到了国外的，网速你懂的；</li>
<li>让你安装第三方闭源驱动和软件的，<strong>必须勾选</strong>，能解决很多开源驱动带来的问题。</li>
</ul>
</li>
<li>安装，然后回到BIOS里面你会惊奇的发现出现了Ubuntu的EFI模式引导项（准确来说是两个，估计是那次我多搞了一个/boot）选择它为第一个。</li>
<li>成功进入Ubuntu</li>
</ol>
<h3 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h3><p>安装OpenCV主要是为了使用外置摄像头进行图像采集。</p>
<p>GitHub上有自动安装版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jayrambhia/Install-OpenCV/tree/master/Ubuntu</span><br></pre></td></tr></table></figure>
<p>进入安装目录下的/2.4，提升*.sh文件的权限并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">chmod a+x *.sh</span><br><span class="line">./opencv2_4_10.sh</span><br></pre></td></tr></table></figure>
<p>然后就会开始<strong>极其漫长</strong>的安装过程。</p>
<blockquote>
<p>第一次安装到某个阶段的时候卡死，<br>硬盘灯不闪，鼠标键盘没反应，我还以为安装失败强行重启了。<br>然后又开始一遍，又卡死。<br>我绝望了，但是冷静了下来，想了想<br>——怕是自己电脑配置太渣。<br>然后在安装前关闭了所有无关程序，<br>唯独打开了系统监视器（即Windows下的任务管理器）。<br>之后就非常惊奇地看到卡死的时候：<br>内存+CPU，全部占用100%<br>然后过了大概一个多小时，又全部降回去了，<br>没过三分钟，又是内存飙到100%，CPU反倒正常了<br>目测过了三个多小时，还是这个样子，倒是命令行每隔十几分钟跳一次字，<br>系统时钟已经卡到了和实际时间存在了十分钟到半小时不等的时差，<br>只有某几次命令行跳字的时候，内存占用下来了一点，系统时间一秒刷新了十几分钟<br>最后一脸无奈地睡了。<br>第二天打开笔记本盖子一看，<br>装好了，老大一个success。</p>
</blockquote>
<h3 id="安装darknet"><a href="#安装darknet" class="headerlink" title="安装darknet"></a>安装darknet</h3><p>打开终端<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">git <span class="built_in">clone</span> http://github.com/pjreddie/darknet.git</span><br><span class="line"><span class="built_in">cd</span> darknet</span><br></pre></td></tr></table></figure></p>
<p>用gedit修改makefile文件<br><strong>令OPENCV=1</strong><br>然后在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h3 id="安装NVIDIA官方GPU驱动"><a href="#安装NVIDIA官方GPU驱动" class="headerlink" title="安装NVIDIA官方GPU驱动"></a>安装NVIDIA官方GPU驱动</h3><p>首先<strong>禁用开源驱动</strong></p>
<p>新建一个.conf文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/modprobe.d/blacklist-nouveau.conf</span><br></pre></td></tr></table></figure>
<p>写入以下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">blacklist lbm-nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line">alias nouveau off</span><br><span class="line">alias lbm-nouveau off</span><br></pre></td></tr></table></figure></p>
<p>保存，重启后再打开终端，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure></p>
<p>无输出即禁用成功</p>
<p>正式开始安装NVIDIA官方驱动了<br>我这里选择的是<strong>直接到系统的“软件和更新”里的“附加驱动”选择安装NVIDIA的专有驱动</strong><br>（不要管他是否显示tested，安装就是了）</p>
<p>等待安装成功后，重启打开终端，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure></p>
<p>正确显示你当前GPU的状况就OK了</p>
<h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><p>CUDA下载地址：<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a><br>选项顺序是Linux-x86_64-Ubuntu-16.04-deb(local)<br>1点多G，然后找个下载速度快的地方下了它，推荐<strong>迅雷等下载工具</strong>，<br>虽然并没有加速，但毕竟服务器在境外，<strong>浏览器没法断点续传</strong>，连接一断就得重新下载。</p>
<p>然后把下载好的文件包拷到“/home/用户名/”目录下，在终端里面输入<br><strong>（注意你的deb文件名不一定是这个，这个是旧版的了）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i cuda-repo-ubuntu1404-7-5-local_7.5-18_amd64.deb</span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install cuda</span><br></pre></td></tr></table></figure>
<p>安装完成后输入<br><strong>（注意你的cuda文件夹不一定是这个7.5的，这个是旧版的了）</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-7.5/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p>
<h3 id="再次安装darknet"><a href="#再次安装darknet" class="headerlink" title="再次安装darknet"></a>再次安装darknet</h3><p>再次用gedit打开makefile<br><strong>（注意你的cuda文件夹不一定是这个7.5的，这个是旧版的了）</strong><br>令开头GPU=1，同时令NVCC = /usr/local/cuda-7.5/bin/nvcc后保存退出<br>然后在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<h2 id="测试darknet"><a href="#测试darknet" class="headerlink" title="测试darknet"></a>测试darknet</h2><h3 id="下载模型-测试模型"><a href="#下载模型-测试模型" class="headerlink" title="下载模型+测试模型"></a>下载模型+测试模型</h3><p>到这儿下载*.weight格式的模型：<a href="http://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">http://pjreddie.com/darknet/yolo/</a></p>
<p>终端切换到darknet的安装目录下<br>示例命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detect cfg/yolo.cfg yolo.weight data/horses.jpg</span><br><span class="line">./darknet yolo <span class="built_in">test</span> cfg/yolo-tiny.cfg yolo-tiny.weight</span><br></pre></td></tr></table></figure></p>
<h3 id="使用电脑-手机摄像头采集图像"><a href="#使用电脑-手机摄像头采集图像" class="headerlink" title="使用电脑/手机摄像头采集图像"></a>使用电脑/手机摄像头采集图像</h3><p>电脑摄像头：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg weights/tiny-yolo-voc.weights</span><br></pre></td></tr></table></figure></p>
<p>手机摄像头：</p>
<p>先在手机上安装好<strong>IP摄像头</strong>APP，配置好地址后，先用浏览器访问以确定视频源的路径<br><strong>(因此这里的地址是你配置并确定好视频源的地址)</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector demo data/coco.data yolo.cfg yolo.weights http://192.168.191.2:8080/video</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/samylee/article/details/51684856" target="_blank" rel="noopener">http://blog.csdn.net/samylee/article/details/51684856</a></li>
<li><a href="http://blog.csdn.net/wjbwjbwjbwjb/article/details/52125475" target="_blank" rel="noopener">http://blog.csdn.net/wjbwjbwjbwjb/article/details/52125475</a></li>
<li><a href="http://blog.csdn.net/u014696921/article/details/65626751" target="_blank" rel="noopener">http://blog.csdn.net/u014696921/article/details/65626751</a></li>
<li><a href="http://blog.csdn.net/wuzuyu365/article/details/52469131" target="_blank" rel="noopener">http://blog.csdn.net/wuzuyu365/article/details/52469131</a></li>
<li><a href="http://blog.csdn.net/zafir_410/article/details/73188228" target="_blank" rel="noopener">http://blog.csdn.net/zafir_410/article/details/73188228</a></li>
<li><a href="http://blog.csdn.net/u013832707/article/details/53438574" target="_blank" rel="noopener">http://blog.csdn.net/u013832707/article/details/53438574</a></li>
<li><a href="https://www.cnblogs.com/jackchen-Net/p/7954138.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackchen-Net/p/7954138.html</a></li>
</ol>
<blockquote>
<p>最后，这是本站的第六篇正式发文，感谢阅读。<br>如有意见和建议，欢迎通过首页的联系方式联系作者，<br>本文参考资料均来源于网络，作者保留相关权利，转载请注明出处。</p>
</blockquote>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>First to NeXT</title>
    <url>/2018/02/14/First-to-NeXT/</url>
    <content><![CDATA[<blockquote>
<p>Maybe it is the first.<br>But in my view, that may be the NeXT.</p>
</blockquote>
<p>名字不重要，形式也不重要，重要的是内容。<br>这里将会陆续发布一些技术工作的经验谈，然而仅仅是经验谈而已。</p>
<a id="more"></a>
<p>更多的都是需要读者自己去探索，<br>这一方天地下，比我们的视野更远的地方。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"First to NeXT"</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是本站第一篇正式发文，感谢阅读！</p>
</blockquote>
]]></content>
      <tags>
        <tag>intro</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes About Recent Projects 1</title>
    <url>/2018/02/15/Notes-About-Recent-Projects-1/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password here." />
    <label for="pass">Enter password here.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes About Recent Projects 2</title>
    <url>/2018/02/17/Notes-About-Recent-Projects-2/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password here." />
    <label for="pass">Enter password here.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading Report on Relation-Shape Convolutional Neural Network for Point Cloud Analysis in CVPR2019</title>
    <url>/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/</url>
    <content><![CDATA[<p>本文是2019年5月《模式识别》专业课的读书报告</p>
<p>主要内容是在阅读中国科学院自动化所模式识别国家重点实验室刘永成团队的CVPR2019会议论文（oral）<br>《用于3D点云分析的形状关系卷积神经网络》过程中的个人理解、要点摘录以及收获和感悟。</p>
<a id="more"></a>
<blockquote>
<p>中文标题：CVPR2019《Relation-Shape Convolutional Neural Network for Point Cloud Analysis》读书报告</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>该论文《Relation-Shape Convolutional Neural Network for Point Cloud Analysis》，即《用于3D点云分析的形状关系卷积神经网络》，是由中国科学院自动化所模式识别国家重点实验室15级在读博士刘永成团队提交的CVPR 2019会议论文。该论文现已入选并拟为会议现场演讲论文。作为IEEE主办的计算机视觉、模式识别和人工智能领域的国际顶级会议，CVPR 2019将于今年6月16~20日在美国加州召开。</p>
<p>论文提出了一种根据局部点之间的几何拓扑关系作为特征进行处理的新型卷积神经网络，从而实现对3D点云的模式识别。基于针对传统2D图像的CNN，该论文提出了扩展到3D点云的Relation-Shape CNN。该方法对¬局部点云子集选取中心点作为采样点，通过对采样点与其他点的几何关系让卷积层从几何关系向量中学习一个高维的映射函数，从而得到了能够对3D点的空间分布进行显示推理的卷积结果，进而有区分度地反映其隐含的3D形状。</p>
<p>Relation-Shape CNN方法在三个主流的点云分析任务上均实现了行业内领先的优秀性能。除此之外，该方法不仅可以从点云中学习3D形状特征，还能从点云的2D投影空间中推理3D形状特征。</p>
<p>笔者（注：以下代表本读书报告作者）看到，近年来，卷积神经网络已经在2D图像这类规则数据的模式识别处理中获得了相当大的成功，而该论文在将卷积神经网络网络扩展到3D点云这类不规则数据的研究方面走出了一大步。</p>
<h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>目前，在3D点云模式识别领域的很多研究工作是集中在将卷积神经网络在识别现有网格数据（例如图像）的成功模式复制到3D点云上，例如将3D点云转化为一般的体元（voxel）或者转化为简单的多视图平面图像等。这些方法都将导致3D点云内在蕴含的复杂几何细节信息的损失。</p>
<p>对此，笔者也十分肯定，传统的2D图像与3D点云的区别相当巨大，在2D图像上的旧有模式识别方法往往不能很好地适合对3D点云的处理。<br>为了直接处理点云数据，PointNet对每个点进行学习并从全局角度提取最终的特征，这种方式却忽略了局部结构，而局部结构已经被证明在图像卷积网络中提取高维度视觉特征的过程中的重要性。为了解决这个问题，一些基于取样和体元（例如Superpoint）的方法被提了出来，它们在一定程度上建立在全局到局部的语义关系的学习上。但是这些方法十分依赖于对于局部点集的高效感知学习，这是十分难以达成的。</p>
<p>笔者在自己个人的实践过程中，也感受到了这一点，对于一类具体的模式识别问题，单纯地依赖现有方法框架的学习效率和训练得出模型的识别效果，其最终的整体性能是相当差的，因为这忽略了很多重要的先验知识，这些先验知识能够通过指导对数据结构、网络结构上的改进来提升整体性能。<br>总体上，对于一组3D点云P的识别目前存在着3类挑战：</p>
<ol>
<li>P往往是无序的，因此需要卷积得到的表征能够满足置换排列的不变性，在笔者看来，也就是说对于某一种特定的排列方式应当能够在其出现在整组点云的任意位置上的情况下被识别出来，也就是对点的输入顺序不敏感。</li>
<li>P是分布在3D空间中的，因此需要卷积得到的表征能够对于例如旋转、偏移变换等常见的几何刚体变换具有语义上的不变性。</li>
<li>P事实上组成了一个特定形状，因此，卷积网络需要具备有区分度的“形状意识”，笔者认为这正意味着需要从各点之间的几何关系推理出其表示的3D形状这一能力，因此才引出了论文的主要思路：根据局部点之间的几何拓扑关系作为特征进行学习的方法。</li>
</ol>
<p>论文表示：问题（1）已经能够通过对称函数很好地解决，然而问题（2）、（3）都需要进行全新的研究工作。这一项研究工作的主要目的就是将一般的2D网格CNN扩展到能够解决以上问题的特殊结构上。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-1.png" alt="pic-1"></p>
<center>图1 点云与点云所表示的潜在形状之间的关系</center>

<p>对于图1，笔者看到，论文根据该图能够说明只有讨论局部的点与点之间的几何拓扑关系，才能够获取3D点云所表示的各个局部所代表的潜在形状关系。<br>综上所述，笔者认为，正如论文在问题提出中的思路，基于关键的先验知识和对于当前问题研究总体进展的把握，使用一定的数学、计算理论工具对系统结构进行改进，是当前研究工作的重要思路。</p>
<h3 id="论文成果"><a href="#论文成果" class="headerlink" title="论文成果"></a>论文成果</h3><p>论文提出了一种根据局部点之间的几何拓扑关系作为特征进行处理的新型卷积神经网络RS-CNN（Relation-Shape Convolutional Neural Network）。该方法的关键在于对点之间的几何拓扑关系进行学习，这种学习方式能够对3D点云中存在内在意义的形状信息进行编码。</p>
<p>特别地，对于整体点云的每个局部的卷积都通过选取该局部点云的中心采样点和其邻居点集构建。然后，这一卷积权重结果被用于学习一般认为是低维的采样点与邻居点集之间的关系在高维度上的表征。通过这一卷积方式，我们就能够获取到对点所在的空间层面的、具有明确推理过程的感知表征。这些感知表征有区分度地反映了特定点集模式构成的潜在形状，从而实现了形状的感知。不仅如此，这些表征能够在各种几何先验知识条件下，包括置换排列的不变性、对于网格数据变换的鲁棒性（例如，旋转和偏移等）。</p>
<p>通过将这些卷积作为基本操作，我们能够构建出一个多层的类似于CNN的深度神经网络架构：RS-CNN。这一架构能够实现在点云分析的过程中进行语义形状感知学习。</p>
<p>之后，论文总结了目前取得的关键成果：</p>
<ul>
<li>提出了一个基于形状学习的新型卷积操作：形状关系卷积。它能够明确地对点之间的几何关系的进行编码，从而得到了良好的形状感知能力和鲁棒性。</li>
<li>提出了一个通过多层形状关系卷积构建的神经网络架构RS-CNN。它能够扩展传统的CNN到为实现点云的语义形状感知学习而构造的特殊架构上。</li>
<li>通过3种具有挑战性的性能评测以及经验性、理论性的分析，展示RS-CNN达到了行业领先的优秀性能。</li>
</ul>
<p>论文还在接下来的相关研究（Related Work）中提到了取得以上成果所基于的行业内目前的研究成果。例如：</p>
<ul>
<li>基于3D到2D视图变换的方法、3D形状向3D表面网格变换的方法。</li>
<li>对3D点云使用深度学习。例如PointNet、PointNet++系列框架，后者开始注意到对于局部结构特征的学习，此外还有Superpoint将点云的部分转化为几何体元，Graph Convolution Network将局部的点云绘制成平面图像进行处理，但以上研究均未考虑到局部点云中点之间的3D空间关系，还有一些将点云映射为高维空间以适应经典CNN应用的研究、以及一些对点云的几何特性例如排列不变性、3D变换的鲁棒性的研究。</li>
<li>关系学习。通过对关系的学习进而得到数据相关的权重的研究、尤其是在3D点云中对于点之间关系的学习在业界已经获得了相当的进展，但大部分研究均没有考虑到局部点之间关系的学习，这也为本论文提出的方法提供了思路。</li>
</ul>
<p>笔者看到，论文作者的研究方向选取是建立在对大量业内相关研究的深刻理解和分析上的。若没有对3D点云分析的整体研究方向具有如此深刻的把握，基本上很难在该领域选取到一个较好的研究方向。</p>
<p>这也可以在作者的GitHub仓库上看出，作者建立了一个GitHub仓库，收集了自2017年以来的点云分析的重要研究文献资料（笔者注：地址为 <a href="https://github.com/Yochengliu/awesome-point-cloud-analysis" target="_blank" rel="noopener">https://github.com/Yochengliu/awesome-point-cloud-analysis</a> ）。这说明了研读相关领域内的重要文献是科研工作的重要组成部分之一，而科研工作取得的成果也基于对前人研究的分析和思考。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>在算法实现方面，论文首先讨论了形状感知的表征学习。论文指出，点云分析的关键就在于有区分度地表示出具有鲁棒性的潜在形状。在这里我们使用基于上下文的形状感知表征学习，通过将传统的网格CNN扩展到一种新型的形状关系卷积（RS-Conv）上来达成这一目的。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-2.png" alt="pic-2"></p>
<center>图2 RS-Conv的概要图</center>

<p>对于图2，论文解释如下：对于中心样本点$x_i$每一个邻居点$x_j$的卷积权重$w_{ij}$，都通过对在预设定的几何关系向量$h_{ij}$（即中心样本点$x_i$与每一个邻居点$x_j$构成的向量）得到的映射Μ中转换得到。</p>
<p>通过这种方式，感知卷积表征 $\sigma(A({ w_{ij}∙f_{x_j},∀x_j }))$（此处的 $f_{x_j}$ 为对于 $x_j$ 的一个特征向量，事实上就是 $x_j$ 的坐标位置等信息）就能够具有表现力地推理出每个点的空间层级，最终得到了高判别度的形状感知能力。正如在图像CNN中那样，进一步的通道数提升的映射被用来产生一个更加强大的形状感知表征。</p>
<p>笔者认为，如图中所示，通过通道数逐步提高的多层感知机（MLP，事实上可以认为是卷积核大小与输入大小相同的CNN）的处理，能够从低维度提取更多的细节特征到更高的维度，从而更加能够更好地识别局部点集构成的潜在形状特征。<br>论文进一步介绍了形状关系卷积的算法推理过程，如下所示。</p>
<h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><p>为了实现局部卷积的归纳学习，我们将局部点云子集$P_{sub}⊂\mathbb{R}^3$建模为一个建模为一个球形邻域，该邻域的中心点为采样点$x_i$，其余点作为$x_i$的邻居点$x_j∈N(x_i )$。在该邻域上，我们构建了一个一般性的卷积操作方法：</p>
<p>$$<br>\begin{equation}<br>f_{P_{sub}}=\sigma(A({ T(f_{x_j}),∀x_j })),d_{ij} &lt; r,∀x_j∈N(x_i)<br>\end{equation}<br>$$</p>
<p>笔者看到，以上一般卷积操作方法中特征变换函数Τ事实上就是神经元模型中的判别函数（最简单的形式即权重向量与特征向量的点乘），该操作方法也同样具有非线性的激活函数，而与普通的神经元不同的是：聚合函数函数$A$，这一函数应当是论文为了能够将整个局部邻域的特征进行聚合从而生成一份单一特征的，从而满足将点云格式的特征转码为经典CNN能够处理的特征格式。</p>
<h4 id="经典CNN的限制"><a href="#经典CNN的限制" class="headerlink" title="经典CNN的限制"></a>经典CNN的限制</h4><p>在经典的网格CNN中，特征变换函数实现为：</p>
<p>$$Τ(f_{x_j} )=w_j∙f_{x_j}$$</p>
<p>其中$w_j$为学习得出的卷积权重，$f_{x_j}$为对于点$x_j$的一个特征向量，点乘符号 ∙ 表示按元素相乘。该卷积方法在点云数据上直接使用会存在两个缺陷：1）由于$w_j$不与其他点共享参数，因此该卷积对于输入点集不具有置换排列不变性。2）在反向传播中，$w_j$的梯度仅与孤立点$x_j$相关，因此该卷积难以捕捉到点间关系。</p>
<h4 id="转换：基于关系的学习"><a href="#转换：基于关系的学习" class="headerlink" title="转换：基于关系的学习"></a>转换：基于关系的学习</h4><p>为了克服上述问题，我们将卷积转换为从几何关系中学习。在方法上，我们将$w_j$替换为$w_{ij}$，并让$w_{ij}$从中心样本点$x_i$与每一个邻居点$x_j$构成的几何关系向量$h_{ij}$中学习一个高维的映射函数$M$。该过程可以描述为：</p>
<p>$$<br>\begin{equation}<br>Τ(f_{x_j})=w_{ij} ∙ f_{x_j}=M(h_{ij})∙f_{x_j}<br>\end{equation}<br>$$</p>
<p>其中，映射函数$M$的目标是从几何先验中学习一个高维的、有表现力的关系表达，以编码 3D 点集的空间布局，这里我们使用共享的多层感知机（MLP）实现映射函数$M$。以这种方式，$w_j$巧妙地转换为$w_{ij}$，它的梯度由预定义的几何先验关系向量$h_{ij}$决定，且与点$x_i$和$x_j$均几何相关。于是，公式$(1)$中的$f_{P_{sub}}$变为：</p>
<p>$$<br>\begin{equation}<br>f_{P_{sub}}=σ(A({M(h_{ij} )∙f_{x_j},∀x_j }))<br>\end{equation}<br>$$</p>
<p>该卷积方法聚集了点$x_i$和所有邻居点$x_j∈N(x_i)$之间的几何关系表达，因此可以对3D 点的空间分布进行显式的推理，进而有区分力的反映其隐含的 3D 形状。其中几何先验$h_{ij}$可以灵活设置，因为使用多层感知机实现的映射函数M能将$h_{ij}$映射为高维的关系向量，以实现与特征$f_{x_j}$进行通道对齐。</p>
<p>笔者看到，论文所描述的共享参数就是几何先验性地让$w_{ij}$从中心样本点$x_i$与每一个邻居点$x_j$构成的几何关系向量$h_{ij}$之中的中心样本点$x_i$。通过$w_{ij}$描述$x_i$与每一个邻居点$x_j$的关系而非$x_j$这孤立一点的权重，将局部点集所描述的整个潜在形状用$x_i$这一共享参数进行相对位置的描述，而非直接使用每一个邻居点$x_j$的绝对位置进行描述，从而从本质上赋予了这一方法置换排列不变性。</p>
<h4 id="通道数提升的映射"><a href="#通道数提升的映射" class="headerlink" title="通道数提升的映射"></a>通道数提升的映射</h4><p>从公式$(3)$中可以看出，$f_{P_{sub}}$对应的通道数量是等于$f_{x_j}$特征向量的。这与经典的图像CNN中，为了能够获得更加抽象的表征而降低图像分辨率，从而增加通道数量的做法不同。因此，如图2的中间部分所示，我们添加了一个基于多层感知机的通道数提升映射来实现这一方法。</p>
<p>之后，论文介绍了RS-Conv这一新型卷积操作的4个特性：</p>
<ul>
<li>置换排列不变性。在映射函数$M(h_{ij})$中，低维的关系$h$和多层感知机$M$都能够实现对点输入顺序的置换排列不变性，因为它们描述的是样本点与邻居点的相对位置关系，对输入顺序不敏感。再加之聚合函数$A$使用的是对称函数，能够在整体上实现置换排列不变性。</li>
<li>对于网格变换的鲁棒性。因为低维的关系$h$描述的是基于3D欧式距离的相对位置关系，因此对于旋转、平移等变换操作具有鲁棒性。</li>
<li>点间关系的互动。RS-Conv的方法创新性地提出了不是对一个孤立的点进行学习而是对点间关系进行学习。</li>
<li>权重的共享，在该方法中这是一个关键的特性，通过对不同的特定点集使用相同的学习函数实现更好地鲁棒性并降低学习的复杂度。在公式$(3)$中，对称函数$A$、共享的多层感知机$M$、以及预先设定的几何先验$h$都独立于特定的点集结构的制约，满足了这一特性。</li>
</ul>
<p>论文进一步讨论了RS-Conv在经典2D网格卷积方面进行应用的能力。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-3.png" alt="pic-3"></p>
<center>图3 使用3×3卷积核的经典2D网格卷积示意图</center>

<p>如图3所示，在2D网格卷积中我们可以注意到，$w_j$总是隐含着$x_i$与$x_j$的一个固定的位置关系，也就是说，$w_j$在学习过程中同样和在RS-Conv一样受到了相对位置关系的限制，实际上编码了一种规则的网格关系。因此，论文提出的形状关系卷积方法具有通用性，同样也能够建模经典的2D网格卷积。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-4.png" alt="pic-4"></p>
<center>图4 应用于点云分类（a）和点云物体分割（b）的RS-CNN结构。<br><br>其中N为点云中点的总数，C为通道数。<br></center>

<p>不仅如此，论文也提到了基于RS-Conv构成的多层卷积神经网络RS-CNN的结构，可以说与经典的CNN极为类似。如图4所示，在点云分类中，由于需要输出对于每一种分类的预测概率，使用了若干层全连接层；而在点云物体分割中，和经典的图像语义分割一样，对于每一层都进行的大范围的连接，从而对多层学习到的表征成功地通过特征传播方法（feature propagation）进行上采样（笔者注：unsample，上采样的作用是能够将特征点还原到源输入格式的空间，例如像素空间或3D点空间，从而达到像素、3D点级别的预测），完成逐个像素或点的预测分割操作。</p>
<p>最后，论文提到RS-Conv和RS-CNN的一些实现细节。</p>
<ul>
<li>RS-Conv的实现。使用的激活函数依然是经典的ReLU函数。在映射函数M中，使用了三层的共享MLP来实现随机连续的映射。低纬度关系h_ij通过10通道的向量定义，格式为（3D欧式距离, $x_i-x_j$, $x_i$，$x_j$），通道数1+3+3+3=10。通道数提升映射使用了单层的MLP实现。而每一层MLP都使用了批归一化（笔者注：batch normalization，能够将每次输入的数据分布进行规范化，让其均匀分布在当前层上，从而加速神经网络的训练速度、防止过拟合）。</li>
<li>用于点云分析的RS-CNN。采样中心点一般选取在距离点云原点最远的的点。在局部点云邻域中，固定数目的邻居点作为一个批次batch进行卷积操作，同时也采取归一化操作来保持领域的中心不变。为了能够实现高效的学习，我们强制RS-CNN学习高于3种不同尺度（笔者注：一般是不同范围上的，虽然邻域本身的球型半径相同，但是学习时选取的领域子集范围可以不同）的邻域关系，但是学习结束之后由于使用的是同一组MLP，因此分享同一份权重，因此与多尺度分组学习（Multi-Scale Grouping, MSG）针对不同尺度生成的多份权重不同。RS-CNN基于PyTorch实现，具体参数此处省略。</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>为了验证RS-CNN的有效性，论文作者在在主流的点云分析任务上进行了测试，包括点云分类、部件分割和法向预测。</p>
<p>ModelNet40上的点云分类结果如表1所示，在仅使用3D坐标和1k个稀疏点作为输入的情况下，RS-CNN仍然实现了最佳分类效果（93.6%的精度）。<br>同样，如图5所示，RS-CNN在给出点数不断随机减少的过程中，分类的准确率下降速度是同类方法中最慢的。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/table-1.png" alt="table-1"></p>
<center>表1 ModelNet40上的形状分类测试结果</center>


<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-5.png" alt="pic-5"></p>
<center>图5 3D点云的点数随机减少过程中不同方法的准确率变化</center>

<p>ShapeNet part上的部件分割效果示意图如图6所示。如表2所示，尽管点云所形成的形状多种多样，并且很容易产生混淆，RS-CNN依然可以准确地将部件分割出来。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/table-2.png" alt="table-2"></p>
<center>表2 ShapeNet part上的形状部件分割测试结果</center>

<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-6.png" alt="pic-6"></p>
<center>图6 形状部件分割测试效果</center>

<p>ModelNet40上的法向预测结果如图7所示。与PointNet以及PointNet++相比，RS-CNN可以取得更加准确的法向预测结果，偏移程度明显较其他模型更小。尽管如此，论文表示，RS-CNN仍然难以有效推理棘手的形状，比如旋转楼梯（可以从图中看出偏移程度较大）以及错综复杂的植物。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-7.png" alt="pic-7"></p>
<center>图7 ModelNet40上的法向预测结果</center>

<p>由于公式（3）中的几何先验$h_{ij}$可以灵活地定义，因此论文在ModelNet40上测试了五个比较直观的例子，结果如表6所示。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/table-6.png" alt="table-6"></p>
<center>表6 不同的几何先验结构对于准确率的影响</center>

<p>可以看到，仅仅使用3D欧式距离作为低维几何关系（model A），RS-CNN依然能够取得92.5%的精度，这是十分令人印象深刻的。而其他的几何先验结构也同样得出了较好的精度。<br>此外，为了测试RS-CNN的几何形状推理能力，我们强制置零某一维的坐标值，即将3D点云投影到2D空间（model E，图9），如表12所示，得到的分类精度均接近92.2。这证明了RS-CNN不仅可以从3D点云中学习3D形状，还能从2D投影空间中推理3D形状。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/pic-8.png" alt="pic-8"></p>
<center>图8 将3D点云投影到XY、XZ、YZ等2D平面上</center>

<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/table-12.png" alt="table-12"></p>
<center>表12 识别3D点云的不同方向2D投影的准确率</center>

<p>为了验证所提出的RS-Conv的鲁棒性，论文设置几何先验$h_{ij}$为3D欧式距离，然后在ModelNet40上进行鲁棒性测试，结果如表7所示。<br>虽然几何关系能够做到旋转不变，但网络初始输入的特征仍然会受到旋转的影响。针对这一问题，我们引入法向将每一个局部点集旋转到以法向和采样点确定的局部坐标系中，实现了旋转不变。但该旋转会给形状识别带来困难，因此分类精度会有所下降。</p>
<p><img src="/2019/06/30/Reading-Report-on-Relation-Shape-Convolutional-Neural-Network-for-Point-Cloud-Analysis-in-CVPR2019/table-7.png" alt="table-7"></p>
<center>表7 通过测试旋转、偏移等操作对于分类精度的影响<br><br>验证论文提出的RS-Conv的鲁棒性<br></center>

<p>其他的测试还有模型简化测试（Ablation Study），对于对称函数A、映射函数M的选取等，RS-CNN在以上测试中均获得了优秀的结果。此处由于篇幅限制，暂且省略。<br>综上，笔者看到，RS-CNN以其具有创新性的对于局部点云的点间几何关系的先验知识作为特征进行学习的优良特性，在使用了类似于经典CNN的网络结构的前提下，依然能够获得相当优良的测试结果。这体现了先验知识作为另一种研究方向的关键作用。</p>
<h3 id="收获体会"><a href="#收获体会" class="headerlink" title="收获体会"></a>收获体会</h3><p>阅毕全文，笔者看到，论文不同于以往研究中对于深度神经网络的层数等结构特征进行改造，而考虑了3D点云内在的几何先验知识，从而成功地针对这些几何先验知识构造出了新的卷积操作形状关系卷积RS-Conv。而且，使用这一全新卷积操作的、类似经典CNN结构的RS-CNN，能够在实验性能对比上超越相当多的对于深度神经网络结构改造的方法。</p>
<p>可以说，这是一次先验知识本质研究相对于经验性结构改造的成功。也正因为该方法在结构上与经典CNN类似，在一定程度上使得对于深度神经网络接触不是特别深入的笔者，在阅读论文过程中遇到的理解上的障碍相对较小。通过阅读本篇论文，笔者有以下的收获体会：</p>
<ul>
<li><p>一种全新的研究思路。笔者认为，论文专注于研究问题中先验知识而非经验性地改造网络结构的思路，对于其他在现有深度神经网络框架下基于复杂不规则数据问题的适配和改进工作，具有很大的启发性。本论文以3D点云特有的几何先验知识为切入点，根据先验知识的指导对经典卷积操作的进行合理改进，在使用类似经典CNN的网络结构的前提下，取得了业界领先的性能测试结果，这是一个基于先验知识改进神经网络基本结构的全新研究思路。</p>
</li>
<li><p>模式识别、深度学习相关论文的基本格式和专业术语。在阅读过程中，笔者进一步巩固了之前已经了解的卷积层、全连接层、多层感知机（MLP）、批归一化（batch normalization）、激活函数、判别函数等专业术语的基本原理和功能作用，并进一步接触了一篇模式识别、深度学习顶级会议论文的基本格式：</p>
<p>1) 简介Introduction提出并解释问题，回顾研究领域内的现有成果，并简要给出自己的方法；<br>2) 相关研究Related Work说明了自己给出的方法是基于哪些现有研究成果；<br>3) 接下来的章节应当具体描述自己给出的方法所用到的数学建模、算法推导、基本结构、特性、实现细节等，全方面地描述这一方法的实现思路；<br>4) 实验测试Experiment通过具体的性能测试结果，图表文结合地来考察该方法的具体性能；<br>5) 结论Conclusion总结上文的要点，通过结论来说明文首简介中提及的内容是得到准确论证的。</p>
</li>
</ul>
<ul>
<li><p>论文写作、排版和文字表达的技巧。在阅读论文的过程中，笔者获得了较好的阅读体验，不存在过多的阅读理解上的障碍，不仅说明了论文本身提出的方法在结构上类似于经典CNN，比较容易理解，而且也说明了作者的论文写作技巧、排版技巧以及文字表达能力是十分优秀的，这也是值得笔者学习的地方。</p>
</li>
<li><p>进一步深入研究的方向。笔者看到，论文仅仅是在类似经典的CNN网络结构上便取得了相当重大的成果，那么是否能够通过对神经网络的结构以及卷积单元的进一步改造从而让该方法的综合性能更上一层楼，便成为了进一步深入研究的方向。</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>论文《Relation-Shape Convolutional Neural Network for Point Cloud Analysis》地址：<br><a href="https://arxiv.org/abs/1904.07601" target="_blank" rel="noopener">https://arxiv.org/abs/1904.07601</a></li>
<li>论文作者刘永成的中文分享：<br><a href="https://mp.weixin.qq.com/s/Jso2YZs2NEtMORZsLkrJ5w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Jso2YZs2NEtMORZsLkrJ5w</a></li>
<li>论文作者建立的2017年以来点云分析的重要研究文献资料GitHub仓库：<br><a href="https://github.com/Yochengliu/awesome-point-cloud-analysis" target="_blank" rel="noopener">https://github.com/Yochengliu/awesome-point-cloud-analysis</a></li>
<li>中文解读：<br><a href="http://www.ijiandao.com/2b/baijia/250710.html" target="_blank" rel="noopener">http://www.ijiandao.com/2b/baijia/250710.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Training Configuration for Yolo-darknet</title>
    <url>/2018/11/28/Training-Configuration-for-Yolo-darknet/</url>
    <content><![CDATA[<blockquote>
<p>Everything’s coming up roses.</p>
</blockquote>
<p>续上次的笔记<br>分享yolo-darknet神经网络训练全过程的配置经验</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于本文中描述的yolo-darknet训练配置流程来源较多，而且训练配置时间为今年暑期，距离本文完稿时间较远，因此本文不可避免地会存在一定的失误和错漏。恳请发现问题的读者不吝赐教，通过首页的联系方式向作者提出宝贵意见。</p>
<h2 id="数据集的标注、修改"><a href="#数据集的标注、修改" class="headerlink" title="数据集的标注、修改"></a>数据集的标注、修改</h2><p>数据集的采集来源以及采集方式属于项目内容，此处暂时不便叙述。对于采集得到的数据集，尤其是针对yolo-darknet的图片数据集，应当至少满足如下的要求：</p>
<ul>
<li>文件名称中不应当出现中文</li>
<li>多次采集得到的文件应当分开命名前缀，否则存在同名文件覆盖的问题</li>
<li>最好是同一种后缀格式，例如jpg格式。后缀大写JPG和小写jpg，darknet不会认为是同一种文件类型而报错。另外，png格式比较灵活，可以强行改成jpg后缀且内容仍可以读取</li>
</ul>
<p>本项目中除了采集了原始数据之外，也通过python脚本对图片素材进行翻转、随机颜色等基本变换来对数据集规模进行扩充。此为额外操作，不影响yolo-darknet训练过程。</p>
<p>数据集的标注采用的是基于python的ImageLabel，标注界面是可视化的，流程基本上是：</p>
<ul>
<li>设置你标注的物体对应的标签，例如dog，cat等，可以设置默认标签</li>
<li>打开素材文件夹到程序中，设置当前的标签，对图片进行逐个画框标注</li>
<li>标注后自动生成数个xml文件，xml文件的内容一般如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">annotation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">folder</span>&gt;</span>图片文件夹<span class="tag">&lt;/<span class="name">folder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filename</span>&gt;</span>图片名称<span class="tag">&lt;/<span class="name">filename</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">path</span>&gt;</span>图片路径<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">database</span>&gt;</span>Unknown<span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">size</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">width</span>&gt;</span>600<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">height</span>&gt;</span>338<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">depth</span>&gt;</span>3<span class="tag">&lt;/<span class="name">depth</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">segmented</span>&gt;</span>0<span class="tag">&lt;/<span class="name">segmented</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">object</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>标签名字<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pose</span>&gt;</span>Unspecified<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">truncated</span>&gt;</span>0<span class="tag">&lt;/<span class="name">truncated</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">difficult</span>&gt;</span>0<span class="tag">&lt;/<span class="name">difficult</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bndbox</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmin</span>&gt;</span>291<span class="tag">&lt;/<span class="name">xmin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymin</span>&gt;</span>76<span class="tag">&lt;/<span class="name">ymin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">xmax</span>&gt;</span>412<span class="tag">&lt;/<span class="name">xmax</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ymax</span>&gt;</span>192<span class="tag">&lt;/<span class="name">ymax</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bndbox</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">annotation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基本上就是对于标注的方框的位置和大小的记录。标注生成的是整个VOC数据集文件夹，一般有两个文件夹：图片文件夹Image和标记文件夹xml。标记文件夹中每一个xml文件的文件名基本上都对应了的图片文件夹中的图片文件。</p>
<p>应当注意的是，一旦移动了xml文件夹或整个数据集文件夹，必须将所有xml文件中的图片文件夹、图片路径改成对应的新文件夹、新路径，否则必然报错。</p>
<p>但问题是，一旦数据集规模像本项目一样巨大时，人工逐个更改xml就十分困难。所以需要python脚本进行批量文件处理。此处摘录一部分代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>) </span><br><span class="line"></span><br><span class="line">path = <span class="string">"/home/blean/VOC/validateImage/"</span></span><br><span class="line">oldpath = <span class="string">"/home/blean/VOC/pos/"</span></span><br><span class="line">newpath = <span class="string">"/home/blean/VOC/Image/"</span></span><br><span class="line">filelist = os.listdir(path)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> files <span class="keyword">in</span> filelist:</span><br><span class="line">    <span class="keyword">if</span> os.path.splitext(files)[<span class="number">1</span>] != <span class="string">".jpg"</span> <span class="keyword">and</span> os.path.splitext(files)[<span class="number">1</span>] != <span class="string">".txt"</span>:</span><br><span class="line">        tmp = os.path.splitext(files)[<span class="number">0</span>]</span><br><span class="line">        os.rename(path+files, path+tmp+<span class="string">".jpg"</span>)</span><br><span class="line">        <span class="comment"># 强行将非jpg的后缀，例如JPG大写后缀或png后缀更改成jpg</span></span><br><span class="line">        <span class="keyword">print</span> path+files</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    tree = ET.parse(path+files)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    filename = root.findall(<span class="string">'filename'</span>)[<span class="number">0</span>].text</span><br><span class="line">    tmp = os.path.splitext(filename)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 寻找xml文件中对应的文件名</span></span><br><span class="line">    <span class="keyword">print</span> path+tmp+<span class="string">".xml"</span></span><br><span class="line">    os.rename(path+files, path+tmp+<span class="string">".xml"</span>)</span><br><span class="line">    <span class="comment"># 同样地将xml文件名改成后缀修改后的图片文件名</span></span><br><span class="line">    root.findall(<span class="string">'path'</span>)[<span class="number">0</span>].text = tmp.replace(oldpath, newpath)</span><br><span class="line">    <span class="comment"># 修改路径</span></span><br><span class="line">    tmp = root.findall(<span class="string">'filename'</span>)[<span class="number">0</span>].text</span><br><span class="line">    <span class="keyword">if</span> tmp.find(<span class="string">"捕获"</span>) != <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">print</span> tmp</span><br><span class="line">        root.findall(<span class="string">'filename'</span>)[<span class="number">0</span>].text = tmp.replace(<span class="string">"捕获"</span>, <span class="string">"buhuo"</span>)</span><br><span class="line">        tree.write(path+files)</span><br><span class="line">    <span class="comment"># 修改某些中文文件名</span></span><br><span class="line">    root.findall(<span class="string">'folder'</span>)[<span class="number">0</span>].text = tmp.replace(<span class="string">"pos"</span>, <span class="string">"Image"</span>)</span><br><span class="line">    <span class="comment"># 修改图片文件夹名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> i</span><br><span class="line"><span class="comment"># 打印总数</span></span><br></pre></td></tr></table></figure>
<p>注：以上代码是本人为了修正数据集格式自行编写的，具有很强的临时性，是不同功能的python代码之间的整合，如果不需要某些功能，可以将对应代码手动注释掉</p>
<h2 id="训练数据集和验证数据集的拆分"><a href="#训练数据集和验证数据集的拆分" class="headerlink" title="训练数据集和验证数据集的拆分"></a>训练数据集和验证数据集的拆分</h2><p>数据集应当分成训练集和验证集，以便于对训练效果进行评估。<br>这里作者直接参考了这篇CSDN上的文章<a href="https://blog.csdn.net/qq_34484472/article/details/73135354" target="_blank" rel="noopener">《YOLO训练自己的数据集》</a>中的python脚本，内容摘录如下：</p>
<blockquote>
</blockquote>
<pre><code>下载链接：http://pan.baidu.com/s/1hs22I7U 密码：wdv0
运行traindata.py：生成trainImage文件夹，存放训练图片；生成trainImageXML文件夹，存放训练图片xml标签；生成validateImage文件夹，存放验证集图片；生成validateImageXML文件夹，存放验证集图片的xml标签。
运行trans.py，生成trainImageLabelTxt文件夹，存放训练图片通过xml标签转化得到的txt文件（若在训练过程提示txt文件找不到，则把此文件夹下的txt文件夹移动到trainImage文件夹）；生成validateImageLabelTxt文件夹，道理一样。
另外得到的trainImagePath.txt和validateImagePath.txt存放着训练图片和验证图片的路径。
</code></pre><blockquote>
</blockquote>
<p>下载好的python脚本一般不能立即用，根据运行python脚本出现的报错，应当对其进行相应的修改，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classes = [<span class="string">"cat"</span>] <span class="comment">#把这个标签改成你自己的数据集中标记的标签</span></span><br><span class="line"><span class="comment">#那个sets看起来很奇怪，但是不用改也能用。python研究的少，暂时不知道具体原因</span></span><br></pre></td></tr></table></figure>
<h2 id="对darknet的配置和更改"><a href="#对darknet的配置和更改" class="headerlink" title="对darknet的配置和更改"></a>对darknet的配置和更改</h2><p>darknet本身并非完全开箱即用的图像识别训练框架，因此需要对它进行有针对性的配置和必要的更改。此处同样是根据<a href="https://blog.csdn.net/qq_34484472/article/details/73135354" target="_blank" rel="noopener">《YOLO训练自己的数据集》</a>以及其他几篇文章的指导和建议进行配置的，主要有以下几点：</p>
<p>首先，对darknet的cfg/voc.data进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classes= 标签类别总数</span><br><span class="line">train = 填之前脚本生成的训练集文件列表trainImageId.txt</span><br><span class="line">valid = 填之前脚本生成的验证集文件列表validateImagePath.txt</span><br><span class="line">names = data/xxx.names</span><br><span class="line">backup = 存放训练结果模型的路径</span><br></pre></td></tr></table></figure>
<p>在data文件夹下的names文件中，每行写一条标签名称</p>
<p>其次，对要使用的神经网络版本yolo2-voc对应的配置文件yolo2-voc.cfg，应当更改以下几处：</p>
<ul>
<li>将最后的[region]层神经网络的配置中的classes改为1（即标记类别的总数）</li>
<li>将最后一个[convolutional]卷积层中的filter改为30（filter的公式filters=(classes+ coords+ 1)<em> (NUM) ，我的是(1+4+1)</em> 5=30）</li>
</ul>
<p>注：这里coords可以认为是坐标，设置的标记是一个方框则取4。NUM是神经网络的层数。filter公式的来源请参见国外开发者们的讨论：<a href="https://groups.google.com/forum/#!topic/darknet/B4rSpOo84yg" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/darknet/B4rSpOo84yg</a></p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>在yolo的官网下载预训练模型，地址：<a href="http://pjreddie.com/media/files/darknet53.conv.74" target="_blank" rel="noopener">http://pjreddie.com/media/files/darknet53.conv.74</a></p>
<p>并执行训练命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector train cfg/voc.data cfg/yolov2-voc.cfg darknet53.conv.74</span><br></pre></td></tr></table></figure>
<p>之后便开始了对神经网络的训练，在1000次训练之内，每100次就在backup文件夹中生成一次权重模型，在1000次训练以上，每10000次生成一次权重模型。本项目的最终训练次数达到了50000次。</p>
<p><img src="/2018/11/28/Training-Configuration-for-Yolo-darknet/training3.png" alt="训练过程截图"></p>
<p>上图为训练到500次左右时的结果截图</p>
<p><img src="/2018/11/28/Training-Configuration-for-Yolo-darknet/training4.png" alt="训练过程截图"></p>
<p>训练生成的模型文件</p>
<h2 id="批量测试、评估以及需要对darknet进行的相应修改"><a href="#批量测试、评估以及需要对darknet进行的相应修改" class="headerlink" title="批量测试、评估以及需要对darknet进行的相应修改"></a>批量测试、评估以及需要对darknet进行的相应修改</h2><p>本人<a href="https://lmy98129.github.io/2018/02/20/Environment-Configuration-for-Yolo-darknet">之前的笔记</a>中曾经提到了使用单张图片测试，以及连接计算机摄像头、网络视频推流进行实时识别的命令，命令内容大致如下：</p>
<p>单张图片：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detect cfg/yolo.cfg yolo.weight data/horses.jpg</span><br></pre></td></tr></table></figure></p>
<p>电脑摄像头：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg weights/tiny-yolo-voc.weights</span><br></pre></td></tr></table></figure></p>
<p>手机摄像头（通过网络视频实时推流，使用工具为IP摄像头APP）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector demo data/coco.data yolo.cfg yolo.weights http://192.168.191.2:8080/video</span><br></pre></td></tr></table></figure>
<p>得到的效果大致如下：</p>
<p>实地场景：</p>
<p><img src="/2018/11/28/Training-Configuration-for-Yolo-darknet/testing7.png" alt="测试过程截图"></p>
<p>网络图片：</p>
<p><img src="/2018/11/28/Training-Configuration-for-Yolo-darknet/testing1.png" alt="测试过程截图"></p>
<p>但是，可以看出这样手动输入命令进行逐个测试的方法，在测试上文中提到的从标记数据集中拆分出来的有一定数量图片的验证集时十分地不友好。而且必须手工收集每次测试中得到的准确度信息、手工进行统计计算。</p>
<p>所以这里参考了CSDN上的另一篇文章<a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754" target="_blank" rel="noopener">《YOLOv3批量测试图片并保存在自定义文件夹下》</a>以及简书上的一篇文章<a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754" target="_blank" rel="noopener">《Darknet 评估训练好的网络的性能》</a>对darknet中的example文件夹下的detector.c文件中的代码进行更改，以便于进行批量测试、统计、评估模型在验证集上的准确度，并输出结果：</p>
<ol>
<li>修改validate_detector_recall函数定义和调用为：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validate_detector_recall</span><span class="params">(<span class="keyword">char</span> *datacfg, <span class="keyword">char</span> *cfgfile, <span class="keyword">char</span> *weightfile)</span></span></span><br><span class="line"><span class="function"><span class="title">validate_detector_recall</span><span class="params">(datacfg, cfg, weights)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改validate_detector_recall的初始化代码</li>
</ol>
<p>修改前：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *plist = get_paths(<span class="string">"data/voc.2007.test"</span>);</span><br><span class="line"><span class="keyword">char</span> **paths = (<span class="keyword">char</span> **)list_to_array(plist);</span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> *options = read_data_cfg(datacfg);</span><br><span class="line"><span class="keyword">char</span> *valid_images = option_find_str(options, <span class="string">"valid"</span>, <span class="string">"/home/blean/VOC/validateImagePath.txt"</span>);</span><br><span class="line"><span class="built_in">list</span> *plist = get_paths(valid_images);</span><br><span class="line"><span class="keyword">char</span> **paths = (<span class="keyword">char</span> **)list_to_array(plist);</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>修改结束后需要重新编译darknet主程序，命令如下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>在完成上述修改后即可使用darknet的recall命令进行评估测试并输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./darknet detector recall cfg/voc.data cfg/yolov2-voc.cfg backup/yolov2-voc_50000.weights -out drowning_recall.txt</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Number Correct Total 	Rps/Img 	IOU 		Recall </span><br><span class="line"> 0     1     1	RPs/Img: 23.00	IOU: 71.42%	Recall:100.00%</span><br><span class="line"> 1     2     2	RPs/Img: 19.00	IOU: 66.04%	Recall:100.00%</span><br><span class="line"> 2     3     3	RPs/Img: 31.00	IOU: 65.52%	Recall:100.00%</span><br><span class="line"> 3     4     4	RPs/Img: 31.75	IOU: 65.22%	Recall:100.00%</span><br><span class="line"> 4     5     5	RPs/Img: 29.40	IOU: 65.55%	Recall:100.00%</span><br><span class="line"> 5     6     6	RPs/Img: 29.67	IOU: 67.34%	Recall:100.00%</span><br><span class="line"> 6     6     7	RPs/Img: 32.00	IOU: 60.25%	Recall:85.71%</span><br><span class="line"> 7     7     8	RPs/Img: 35.12	IOU: 59.75%	Recall:87.50%</span><br><span class="line"> 8     8     9	RPs/Img: 33.11	IOU: 60.55%	Recall:88.89%</span><br><span class="line"> 9     8    10	RPs/Img: 33.20	IOU: 59.48%	Recall:80.00%</span><br><span class="line">10     9    11	RPs/Img: 34.00	IOU: 59.27%	Recall:81.82%</span><br><span class="line">11    10    12	RPs/Img: 33.00	IOU: 59.65%	Recall:83.33%</span><br><span class="line">12    11    13	RPs/Img: 32.00	IOU: 60.33%	Recall:84.62%</span><br><span class="line">13    12    14	RPs/Img: 30.64	IOU: 60.85%	Recall:85.71%</span><br><span class="line">14    12    14	RPs/Img: 29.60	IOU: 60.85%	Recall:85.71%</span><br><span class="line">15    13    15	RPs/Img: 29.62	IOU: 61.41%	Recall:86.67%</span><br></pre></td></tr></table></figure>
<p>其中各项参数的解释如下：</p>
<ul>
<li>Number表示处理到第几张图片。</li>
<li>Correct表示正确的识别出了多少bbox（即标记目标物体的方框）。这个值算出来的步骤是这样的，丢进网络一张图片，网络会预测出很多bbox，每个bbox都有其置信概率，概率大于threshold的bbox与实际的bbox，也就是labels中txt的内容计算IOU，找出IOU最大的bbox，如果这个最大值大于预设的IOU的threshold，那么correct加1。</li>
<li>Total表示实际有多少个bbox。</li>
<li>Rps/img表示平均每个图片会预测出来多少个bbox。</li>
<li>IOU： 这个是预测出的bbox和实际标注的bbox的交集 除以 他们的并集。显然，这个数值越大，说明预测的结果越好。</li>
<li>Recall召回率， 意思是检测出物体的个数 除以 标注的所有物体个数。通过代码我们也能看出来就是Correct除以Total的值。</li>
</ul>
<p>可以从最后一条代表处理了全部验证集的统计结果看出，经过验证集的检验，训练得出的模型识别目标物体的总正确率大致在86%左右，可以说训练效果较为理想。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>YOLO-darknet官网<br><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">https://pjreddie.com/darknet/yolo/</a></li>
<li>YOLO训练自己的数据集：<br><a href="https://blog.csdn.net/qq_34484472/article/details/73135354" target="_blank" rel="noopener">https://blog.csdn.net/qq_34484472/article/details/73135354</a></li>
<li>YOLOv3批量测试图片并保存在自定义文件夹下：<br><a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/79989754</a></li>
<li>Darknet 评估训练好的网络的性能：<br><a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/79989754</a></li>
<li>Environment-Configuration-for-Yolo-darknet | NeXT （就是之前的那篇笔记）<br><a href="https://lmy98129.github.io/2018/02/20/Environment-Configuration-for-Yolo-darknet">https://lmy98129.github.io/2018/02/20/Environment-Configuration-for-Yolo-darknet</a></li>
</ol>
<blockquote>
<p>最后，这是本站的第八篇正式发文，感谢阅读。<br>如有意见和建议，欢迎通过首页的联系方式联系作者，<br>本文参考资料均来源于网络，作者保留相关权利，转载请注明出处。</p>
</blockquote>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Training DeepID1 Network for Face Comparison with Google Colab+Tensorflow</title>
    <url>/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/</url>
    <content><![CDATA[<p>本文由2019年6月《软件工程》必修课的课程设计报告的AI部分改编</p>
<p>主要介绍了“员工考勤管理系统”课程设计中的员工人脸打卡子系统<br>该系统使用了Google CoLab提供的在线Tensorflow GPU平台训练得到的DeepID人脸特征提取比对模型，<br>以及基于该模型搭建的Tensorflow+OpenCV+Flask人脸比对Python服务器</p>
<a id="more"></a>
<blockquote>
<p>中文标题：使用Google CoLab+Tensorflow训练DeepID1人脸比对模型</p>
</blockquote>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><ol>
<li><a href="https://colab.research.google.com/drive/1BKcLNYjffhhQEWQErclZMojsjBpTViSq" target="_blank" rel="noopener">Google CoLab</a>（需要访问国外网站的能力）</li>
<li>GitHub（待发布）</li>
</ol>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/deepid.png" alt="deepid"></p>
<center>图1.1 DeepID的网络结构<br>其中DeepID层能够提取出160维特征向量<br><br></center>

<p>DeepID是香港中文大学王晓刚教授团队在CVPR2014上发表的论文《Deep Learning Face Representation from Predicting 10,000 Classes》提出的方法，全称为Deep hidden IDentity feature（DeepID）。</p>
<p>该方法是一种特征提取的算法，对于一个多层卷积-池化网络进行多分类任务训练后，在其中一层中间层DeepID层能够提取出输入的任意人脸图片的160维深层次特征向量（实际上是160x2x60维的特征向量）。</p>
<p>而这种特征提取的能力是面向任意的（需要经过预先裁剪和对齐后的）人脸图像的，因此作者做出了一个形象的比喻：即使是分10000个类，网络也能够有效区分出每个类别的人脸的显著特征（从而通过特征之间的距离，识别出两张人脸是否为同一人）。</p>
<p>因此，这一方法体现出的以下特性，使得我们最终在众多人脸特征提取方法中选取了DeepId:</p>
<ol>
<li>方法实现的<strong>仅需一次训练即可获得的人脸特征提取能力</strong>，十分适合企业员工人脸考勤环境下员工人脸库经常性变动、待对比人脸图像来源较为复杂的应用场景。</li>
<li>方法的<strong>网络结构简单，易于理解和实现。同时，网络层数较少，</strong>相应地也能够减少训练所消耗的时间和硬件资源，便于我们在短周期（8周，AI子系统开发仅一周）的软件工程课程设计开发过程中安排进度。最终，该算法的训练时长在Google CoLab上为50000次/2小时。</li>
<li>方法的<strong>准确率较高</strong>，在Tensorflow的实现+YouTube Aligned Faces数据集上的测试集人脸比对识别准确率能够达到96%。</li>
</ol>
<p>当然，这一方法作为一个2014年提出的方法，（也是DeepID三代中的第一个版本）也存在着一定的缺陷：</p>
<ol>
<li><strong>仅适用于提取图像中的正脸</strong>，也就是通过摄像头正对人脸拍摄的、或者是通过一定图像处理算法重新对齐的人脸。对于侧脸、带有一定歪斜的人脸等日常生活中常见的人脸图像，识别能力大打折扣。<strong>也正因如此，GitHub上DeepID的Tensorflow实现采用了Youtube Aligned Faces数据集，已经做过了人脸对齐的预处理</strong>，用来训练DeepID较为方便。</li>
<li>在实际使用的过程中，笔者发现这一模型对于裁剪得出的人脸图像的<strong>光线明暗、是否佩戴眼镜</strong>等变化是敏感的，只有在光照条件、脸部配饰等状况近似于人脸图像采集时的情况下，才能够被识别为同一人。</li>
</ol>
<p>因此，目前主流的人脸特征比对方法都聚焦在人脸检测阶段的多特征点提取、侧脸特征点的重新对齐、人脸3D模型识别（一个最著名的案例，就是Apple在iPhone上用于FaceID的3D结构光特征点识别方案）等研究方向。<br>至于Google Colab，是谷歌打造的的一个在线深度学习平台，基于Jupyter Notebook+Tensorflow，能够通过简单的配置，使用Google免费提供的云端GPU资源，从而无需本地硬件资源地轻松训练自己的神经网络。在很久之前的一次计设校赛上曾经使用过这一平台，因此本项目也继续使用这个平台对DeepID网络进行训练。</p>
<h3 id="训练环境搭建"><a href="#训练环境搭建" class="headerlink" title="训练环境搭建"></a>训练环境搭建</h3><p>访问 <a href="https://colab.research.google.com，如果没有谷歌账号可以先去注册一个，列表中是已有的Jupyter" target="_blank" rel="noopener">https://colab.research.google.com，如果没有谷歌账号可以先去注册一个，列表中是已有的Jupyter</a> Notebook文件，创建的文件一般会放在Google 云端硬盘的<code>/colab notebook</code>文件夹下。一般是创建Python 3笔记本，</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/colab-1.png" alt="colab"></p>
<center>图2.1 Google Colab的初始界面</center>

<p>Colab的环境初始化结束后，呈现的是经典的jupyter notebook界面，先点击“代码执行程序-更改运行时类型”，将“硬件加速器”从“None”修改为“GPU”，这样就可以<strong>免费使用基于谷歌提供的云端Nvidia GTX Tesla T4 GPU的Tensorflow GPU版本，显存15GB</strong>，比自己笔记本的4G独显性能高多了。</p>
<p><strong>注意！千万不要选择TPU！</strong> </p>
<p>虽然TPU是Google推出的号称Tensorflow专用的GPU平台，但是其训练速度真的难以接受，在下文我会附上GPU和TPU训练DeepID网络时的Tensorboard检测到的数据，足以体现两者之间的性能差异。</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/colab-2.png" alt="colab"></p>
<center>图2.2 在Colab选取GPU<br></center>

<p>之后可以在左侧边栏中，查看文件目录，会发现一个“挂在Google云端硬盘”的选项，点击之后就会生成一个cell。内容大致为<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行此单元格即可装载您的 Google 云端硬盘。</span></span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">'/content/drive'</span>)</span><br></pre></td></tr></table></figure></p>
<p>运行之后，会生成一个链接拿到Google 云端硬盘生成的授权码，输入到这个cell中，即可成功挂在你的Google 云硬盘。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Go to this URL <span class="keyword">in</span> a browser: https://accounts.google.com/o/oauth2/auth?....</span><br><span class="line"></span><br><span class="line">Enter your authorization code:</span><br><span class="line">··········</span><br><span class="line">Mounted at /content/drive</span><br></pre></td></tr></table></figure></p>
<p>之所以需要挂载Google云硬盘，是基于这样的考虑：</p>
<p>Google Colab有一个“防挖矿”机制，为了防止自己免费开放的GPU资源被矿工拿来挂机挖矿，Colab会自动回收那些运行了很久或者和网页端断线很久的项目的<strong>所有资源：包括GPU和所有文件</strong>。</p>
<p>因此尽量不要尝试在训练的过程中关闭浏览器，然后等时间到了再次打开浏览器查看结果，很有可能早已训练结束，模型文件已经生成，但是由于Colab的这个机制导致文件被删除。</p>
<p>所以在训练过程中，需要挂载Google 云端硬盘，<strong>将模型文件和训练生成的Tensorboard日志的路径放在云端硬盘里</strong>，就算谷歌回收了资源也能够及时保存。</p>
<p>但是，需要注意的是，<strong>数据集最好不要放在Google 云端硬盘里</strong>，因为网上有人试过了，Colab从Google云端硬盘上获取文件时不是直接读取文件系统，而是发送请求进行文件分块下载的，这个网络IO带来的延迟会极大地拖慢训练的速度。</p>
<p>此外，这个数据集直接上传到Google Colab上的速度也是堪忧。但是，值得称赞的是，<strong>在Colab里直接用Shell命令下载在线的数据集</strong>，速度极快，能够达到15M/s。以下是下载YouTube Aligned Faces数据集的输出，30秒完成~</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/colab-3.png" alt="数据集下载"></p>
<center>图2.3 下载YouTube Aligned Faces数据集的输出</center>

<p>还有一个需要注意的地方，就是Colab上已经装好了Tensorflow 1.14、OpenCV以及matplot、numpy、PIL等深度学习常用的python库，若需要其他库也是直接执行shell命令pip install即可。<strong>这里的Tensorflow 1.14与目前常用的1.x版本相比，在API上有着许多区别</strong>，如果直接复制他人的代码，会出现许多的问题。</p>
<p>笔者也因此几乎是把GitHub上的DeepID实现从头开始添加中文注释和改写API，学到了很多搭建Tensorflow训练框架的相关API用法（例如session、variable和namescope），也算是继续了之前《人工智能》大作业的“注释阅读法”的个人习惯。</p>
<p>以上就是一些搭建Colab环境的注意事项，如果你已经看懂了这些，而且熟悉Jupyter Notebook，就可以开始着手编写训练代码了。</p>
<h3 id="编写训练代码"><a href="#编写训练代码" class="headerlink" title="编写训练代码"></a>编写训练代码</h3><h4 id="下载YouTube-Aligned-Faces数据集"><a href="#下载YouTube-Aligned-Faces数据集" class="headerlink" title="下载YouTube Aligned Faces数据集"></a>下载YouTube Aligned Faces数据集</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载youtube aligned face数据集</span></span><br><span class="line">!wget --http-user=wolftau --http-password=wtal997 http://www.cslab.openu.ac.il/download/wolftau/aligned_images_DB.tar.gz</span><br><span class="line"><span class="comment"># 解压下载的数据集</span></span><br><span class="line">!mkdir -p data</span><br><span class="line">!tar -zxf aligned_images_DB.tar.gz -C Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/data</span><br></pre></td></tr></table></figure>
<h4 id="裁剪数据集图片"><a href="#裁剪数据集图片" class="headerlink" title="裁剪数据集图片"></a>裁剪数据集图片</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  此处开始为DeepID人脸特征提取、比对代码</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  来源为：https://github.com/jinze1994/DeepID1</span></span><br><span class="line"><span class="string">  主要工作：增加了详细中文注释、更新了部分tensorflow2.0的新API</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  crop.py</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  裁剪训练数据集图片，图片已经经过了对齐预处理</span></span><br><span class="line"><span class="string">  所谓对齐就是裁剪到只剩下人脸，且已经事先将带有倾斜的人脸对齐过了</span></span><br><span class="line"><span class="string">  因此此处只需裁剪并缩放到 (55,47) 的像素即可</span></span><br><span class="line"><span class="string">  这样的处理适合被检测对象配合、也就是主动进行识别的场景</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  crop_img_by_half_center</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  从1/4处开始裁剪1/2尺寸的图像并缩放</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crop_img_by_half_center</span><span class="params">(src_file_path, dest_file_path)</span>:</span></span><br><span class="line">    <span class="comment"># 打开图像</span></span><br><span class="line">    im = Image.open(src_file_path)</span><br><span class="line">    <span class="comment"># 获取图像尺寸</span></span><br><span class="line">    x_size, y_size = im.size</span><br><span class="line">    <span class="comment"># 开始裁剪的坐标</span></span><br><span class="line">    start_point_xy = x_size / <span class="number">4</span></span><br><span class="line">    <span class="comment"># 裁剪结束时的坐标</span></span><br><span class="line">    end_point_xy   = x_size / <span class="number">4</span> + x_size / <span class="number">2</span></span><br><span class="line">    <span class="comment"># 生成方形框</span></span><br><span class="line">    box = (start_point_xy, start_point_xy, end_point_xy, end_point_xy)</span><br><span class="line">    <span class="comment"># 裁剪</span></span><br><span class="line">    new_im = im.crop(box)</span><br><span class="line">    <span class="comment"># 缩放为（55，47）</span></span><br><span class="line">    new_new_im = new_im.resize((<span class="number">47</span>,<span class="number">55</span>))</span><br><span class="line">    <span class="comment"># 保存</span></span><br><span class="line">    new_new_im.save(dest_file_path)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  walk_through_the_folder_for_crop</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  遍历数据集文件夹，进行图像的处理，生成目标文件夹</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk_through_the_folder_for_crop</span><span class="params">(aligned_db_folder, result_folder)</span>:</span></span><br><span class="line">    <span class="comment"># 若不存在目标文件夹，新建一个</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_folder):</span><br><span class="line">        os.mkdir(result_folder)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开每一个youtube人物文件夹</span></span><br><span class="line">    <span class="keyword">for</span> people_folder <span class="keyword">in</span> os.listdir(aligned_db_folder):</span><br><span class="line">        src_people_path = aligned_db_folder + people_folder + <span class="string">'/'</span></span><br><span class="line">        dest_people_path = result_folder + people_folder + <span class="string">'/'</span></span><br><span class="line">        <span class="comment"># 创建每一个人物文件夹对应的目标文件夹</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_people_path):</span><br><span class="line">            os.mkdir(dest_people_path)</span><br><span class="line">        <span class="comment"># 打开每一个人物文件夹下的视频文件夹</span></span><br><span class="line">        <span class="keyword">for</span> video_folder <span class="keyword">in</span> os.listdir(src_people_path):</span><br><span class="line">            src_video_path = src_people_path + video_folder + <span class="string">'/'</span></span><br><span class="line">            dest_video_path = dest_people_path + video_folder + <span class="string">'/'</span></span><br><span class="line">            <span class="comment"># 创建每一个视频文件夹对应的目标文件夹 </span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_video_path):</span><br><span class="line">                os.mkdir(dest_video_path)</span><br><span class="line">            <span class="comment"># 对于每一个视频文件夹下的图片文件，进行处理</span></span><br><span class="line">            <span class="keyword">for</span> img_file <span class="keyword">in</span> os.listdir(src_video_path):</span><br><span class="line">                src_img_path = src_video_path + img_file</span><br><span class="line">                dest_img_path = dest_video_path + img_file</span><br><span class="line">                crop_img_by_half_center(src_img_path, dest_img_path)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  裁剪模块的主程序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 数据集路径和目标文件夹路径</span></span><br><span class="line">    aligned_db_folder = <span class="string">"data/aligned_images_DB"</span></span><br><span class="line">    result_folder = <span class="string">"data/crop_images_DB"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> aligned_db_folder.endswith(<span class="string">'/'</span>):</span><br><span class="line">        aligned_db_folder += <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result_folder.endswith(<span class="string">'/'</span>):</span><br><span class="line">        result_folder += <span class="string">'/'</span></span><br><span class="line">    <span class="comment"># 开始处理</span></span><br><span class="line">    walk_through_the_folder_for_crop(aligned_db_folder, result_folder)</span><br></pre></td></tr></table></figure>
<h4 id="分割数据集为训练集、验证集和测试集"><a href="#分割数据集为训练集、验证集和测试集" class="headerlink" title="分割数据集为训练集、验证集和测试集"></a>分割数据集为训练集、验证集和测试集</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  split.py</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">   对剪裁后的数据集文件按照 8:1:1 的规模进行切分，分别作为训练集、验证集和测试集。</span></span><br><span class="line"><span class="string">   每个人保留固定数目的图片（100张）进行训练。</span></span><br><span class="line"><span class="string">   为生成测试集，对每个人构造 5 对同一个人的图片 pair，再构造 5 对不同人的图片 pair，作为测试集。</span></span><br><span class="line"><span class="string">   一个pair作为每次测试时输入的组合，用来测试同一个人是否能正确匹配、不同人是否能够分出不同的人脸比对效果</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  fatch_pics_for_one_user</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  获取一个youtube用户的所有图片</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fatch_pics_for_one_user</span><span class="params">(people_path)</span>:</span></span><br><span class="line">    people_imgs = []</span><br><span class="line">    <span class="comment"># 从文件夹中遍历</span></span><br><span class="line">    <span class="keyword">for</span> video_folder <span class="keyword">in</span> os.listdir(people_path):</span><br><span class="line">        <span class="keyword">for</span> video_file_name <span class="keyword">in</span> os.listdir(os.path.join(people_path, video_folder)):</span><br><span class="line">            people_imgs.append(os.path.join(people_path, video_folder, video_file_name))</span><br><span class="line">    random.shuffle(people_imgs)</span><br><span class="line">    <span class="keyword">return</span> people_imgs</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  build_dataset</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  创建训练集、验证集和测试集</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dataset</span><span class="params">(src_folder)</span>:</span></span><br><span class="line">    <span class="comment"># 总人数，总图片张数</span></span><br><span class="line">    total_people, total_picture = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 测试用户列表、验证集、训练集</span></span><br><span class="line">    test_people, valid_set, train_set = [], [], []</span><br><span class="line">    <span class="comment"># 标签数量</span></span><br><span class="line">    label = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用户文件夹遍历</span></span><br><span class="line">    <span class="keyword">for</span> people_folder <span class="keyword">in</span> os.listdir(src_folder):</span><br><span class="line">        <span class="comment"># 获取一个youtube用户的所有图片</span></span><br><span class="line">        people_imgs = fatch_pics_for_one_user(os.path.join(src_folder, people_folder))</span><br><span class="line">        total_people += <span class="number">1</span></span><br><span class="line">        total_picture += len(people_imgs)</span><br><span class="line">        <span class="comment"># 若数量在100张以内，则全部放入测试用户列表</span></span><br><span class="line">        <span class="comment"># 保证测试集中的用户不会出现在训练集和验证集中</span></span><br><span class="line">        <span class="keyword">if</span> len(people_imgs) &lt; <span class="number">100</span>:</span><br><span class="line">            test_people.append(people_imgs)</span><br><span class="line">        <span class="comment"># 否则分割到验证集和训练集中，1:9</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            valid_set += zip(people_imgs[:<span class="number">10</span>], [label]*<span class="number">10</span>)</span><br><span class="line">            train_set += zip(people_imgs[<span class="number">10</span>:<span class="number">100</span>], [label]*<span class="number">90</span>)</span><br><span class="line">            label += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 测试集</span></span><br><span class="line">    test_set = []</span><br><span class="line">    <span class="comment"># 从测试用户列表中，构造5对同一个人的照片、5对不同人的照片</span></span><br><span class="line">    <span class="keyword">for</span> i, people_imgs <span class="keyword">in</span> enumerate(test_people):</span><br><span class="line">        <span class="comment"># 5对同一个人的照片</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            same_pair = random.sample(people_imgs, <span class="number">2</span>)</span><br><span class="line">            test_set.append((same_pair[<span class="number">0</span>], same_pair[<span class="number">1</span>], <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 5对不同人的照片</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> j == i:</span><br><span class="line">                j = random.randint(<span class="number">0</span>, len(test_people)<span class="number">-1</span>)</span><br><span class="line">            test_set.append((random.choice(test_people[i]), random.choice(test_people[j]), <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打乱各个数据集的顺序</span></span><br><span class="line">    random.shuffle(test_set)</span><br><span class="line">    random.shuffle(valid_set)</span><br><span class="line">    random.shuffle(train_set)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出各数据集的统计信息</span></span><br><span class="line">    print(<span class="string">'\tpeople\tpicture'</span>)</span><br><span class="line">    print(<span class="string">'total:\t%6d\t%7d'</span> % (total_people, total_picture))</span><br><span class="line">    print(<span class="string">'test:\t%6d\t%7d'</span> % (len(test_people), len(test_set)))</span><br><span class="line">    print(<span class="string">'valid:\t%6d\t%7d'</span> % (label, len(valid_set)))</span><br><span class="line">    print(<span class="string">'train:\t%6d\t%7d'</span> % (label, len(train_set)))</span><br><span class="line">    <span class="keyword">return</span> test_set, valid_set, train_set</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  set_to_csv_file</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  保存到csv文件中</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_to_csv_file</span><span class="params">(data_set, file_name)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(file_name, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_set:</span><br><span class="line">            print(<span class="string">" "</span>.join(map(str, item)), file=f)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  数据集切分模块的主程序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    random.seed(<span class="number">7</span>)</span><br><span class="line">    <span class="comment"># 原始数据集路径以及各数据集保存列表文件</span></span><br><span class="line">    src_folder     = <span class="string">"data/crop_images_DB"</span></span><br><span class="line">    test_set_file  = <span class="string">"data/test_set.csv"</span></span><br><span class="line">    valid_set_file = <span class="string">"data/valid_set.csv"</span></span><br><span class="line">    train_set_file = <span class="string">"data/train_set.csv"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> src_folder.endswith(<span class="string">'/'</span>):</span><br><span class="line">        src_folder += <span class="string">'/'</span></span><br><span class="line">    </span><br><span class="line">    test_set, valid_set, train_set = build_dataset(src_folder)</span><br><span class="line">    set_to_csv_file(test_set,  test_set_file)</span><br><span class="line">    set_to_csv_file(valid_set, valid_set_file)</span><br><span class="line">    set_to_csv_file(train_set, train_set_file)</span><br></pre></td></tr></table></figure>
<h4 id="向量化数据集，便于读取"><a href="#向量化数据集，便于读取" class="headerlink" title="向量化数据集，便于读取"></a>向量化数据集，便于读取</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  vec.py</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  将数据格式化为向量形式，存入 data/dataset.pkl。便于训练时直接从该文件读取数据。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  vectorize_imgs</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  将图像向量化，事实上就是将图像转化为浮点数格式的数组</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorize_imgs</span><span class="params">(img_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> Image.open(img_path) <span class="keyword">as</span> img:</span><br><span class="line">        arr_img = np.asarray(img, dtype=<span class="string">'float32'</span>)</span><br><span class="line">        <span class="keyword">return</span> arr_img</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  read_csv_file</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  读取csv文件</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv_file</span><span class="params">(csv_file)</span>:</span></span><br><span class="line">    x, y = [], []</span><br><span class="line">    <span class="keyword">with</span> open(csv_file, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            path, label = line.strip().split()</span><br><span class="line">            x.append(vectorize_imgs(path))</span><br><span class="line">            y.append(int(label))</span><br><span class="line">    <span class="keyword">return</span> np.asarray(x, dtype=<span class="string">'float32'</span>), np.asarray(y, dtype=<span class="string">'int32'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  read_csv_pair_file</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  读取成对数据（也就是一个label对应两张图）的csv文件</span></span><br><span class="line"><span class="string">  事实上就是读取测试集数据</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_csv_pair_file</span><span class="params">(csv_file)</span>:</span></span><br><span class="line">    x1, x2, y = [], [], []</span><br><span class="line">    <span class="keyword">with</span> open(csv_file, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">            p1, p2, label = line.strip().split()</span><br><span class="line">            x1.append(vectorize_imgs(p1))</span><br><span class="line">            x2.append(vectorize_imgs(p2))</span><br><span class="line">            y.append(int(label))</span><br><span class="line">    <span class="keyword">return</span> np.asarray(x1, dtype=<span class="string">'float32'</span>), np.asarray(x2, dtype=<span class="string">'float32'</span>), np.asarray(y, dtype=<span class="string">'int32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  向量化主程序，将csv文件转换为pkl文件</span></span><br><span class="line"><span class="string">'''</span>      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    testX1, testX2, testY = read_csv_pair_file(<span class="string">'data/test_set.csv'</span>)</span><br><span class="line">    validX, validY = read_csv_file(<span class="string">'data/valid_set.csv'</span>)</span><br><span class="line">    trainX, trainY = read_csv_file(<span class="string">'data/train_set.csv'</span>)</span><br><span class="line"></span><br><span class="line">    print(testX1.shape, testX2.shape, testY.shape)</span><br><span class="line">    print(validX.shape, validY.shape)</span><br><span class="line">    print(trainX.shape, trainY.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导入向量化的数据到pkl文件中</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'data/dataset.pkl'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        pickle.dump(testX1, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(testX2, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(testY , f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(validX, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(validY, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(trainX, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line">        pickle.dump(trainY, f, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure>
<h4 id="运行tensorboard监视训练过程"><a href="#运行tensorboard监视训练过程" class="headerlink" title="运行tensorboard监视训练过程"></a>运行tensorboard监视训练过程</h4><p>在经过了以上漫长的数据集裁剪、分割和向量化过程（第1、2步各需要20分钟）之后，就开始了训练。这里可以选用Colab内置的Tensorboard进行训练过程的监视。首先需要升级，否则无法读取训练过程中生成的日志文件。</p>
<p>在实际使用过程中，<strong>若训练生成的日志放在了Colab的文件目录中</strong>，Tensorboard在训练开始后过一段时间会与训练程序断开连接，<br>因此同样需要将训练程序代码中的日志文件路径设为Google 云端硬盘的路径。这样就算掉线了也能够在本地运行一个Tensorboard，手动下载Google 云端硬盘上不断更新的日志文件进行监视（或者有下载Google云端硬盘的客户端，可以使用文件夹同步功能实时更新本地的日志文件）。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  训练之前，运行tensorboard监视训练过程</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  尝试了无数次，读不到日志文件，无论是绝对路径还是相对路径</span></span><br><span class="line"><span class="string">  在mac上本地查看日志文件，是能用的，</span></span><br><span class="line"><span class="string">  后来发现升级一下tensorboard就好了，</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级，升级后首次使用会报错，清除一下报错里面提示的info文件即可</span></span><br><span class="line"><span class="comment"># !pip install --upgrade tensorboard</span></span><br><span class="line"><span class="comment"># !rm /tmp/.tensorboard-info/pid-*.info</span></span><br><span class="line"></span><br><span class="line">%reload_ext tensorboard</span><br><span class="line">%tensorboard --logdir <span class="string">"/content/drive/My Drive/Colab Notebooks/deepid/log"</span></span><br></pre></td></tr></table></figure>
<h4 id="训练DeepID网络"><a href="#训练DeepID网络" class="headerlink" title="训练DeepID网络"></a>训练DeepID网络</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  deepid1.py</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  DeepID网络训练主程序</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  load_data</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  从pkl向量文件中导出数据</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'data/dataset.pkl'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        testX1 = pickle.load(f)</span><br><span class="line">        testX2 = pickle.load(f)</span><br><span class="line">        testY  = pickle.load(f)</span><br><span class="line">        validX = pickle.load(f)</span><br><span class="line">        validY = pickle.load(f)</span><br><span class="line">        trainX = pickle.load(f)</span><br><span class="line">        trainY = pickle.load(f)</span><br><span class="line">        <span class="keyword">return</span> testX1, testX2, testY, validX, validY, trainX, trainY</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入向量数据</span></span><br><span class="line">testX1, testX2, testY, validX, validY, trainX, trainY = load_data()</span><br><span class="line"><span class="comment"># 类型数量=训练集数量，也就是认为每一个训练集数据均为一类</span></span><br><span class="line"><span class="comment"># 因为本网络只负责特征提取而非分类，所以可以这么做</span></span><br><span class="line">class_num = np.max(trainY) + <span class="number">1</span></span><br><span class="line"><span class="comment"># 清除一下当前的作用域</span></span><br><span class="line">tf.reset_default_graph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  weight_variable</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  初始化权重，shape事实上是卷积核尺寸</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span><br><span class="line">        <span class="comment"># 从截断的正态分布中输出随机值，以初始化权重。</span></span><br><span class="line">        <span class="keyword">return</span> tf.Variable(tf.truncated_normal(shape, stddev=<span class="number">0.1</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  bias_variable</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  初始化偏置，也就是wx+b中的b，bias</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'biases'</span>):</span><br><span class="line">        <span class="comment"># 使用全零向量初始化偏置</span></span><br><span class="line">        <span class="keyword">return</span> tf.Variable(tf.zeros(shape))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  Wx_plus_b</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  求wx+b</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Wx_plus_b</span><span class="params">(weights, x, biases)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'Wx_plus_b'</span>):</span><br><span class="line">        <span class="keyword">return</span> tf.matmul(x, weights) + biases</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  nn_layer</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  n*n的全连接层，可选激活函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_layer</span><span class="params">(input_tensor, input_dim, output_dim, layer_name, act=tf.nn.relu)</span>:</span></span><br><span class="line">    <span class="comment"># 进入对应层的命名空间</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">        <span class="comment"># 权重</span></span><br><span class="line">        weights = weight_variable([input_dim, output_dim])</span><br><span class="line">        <span class="comment"># 偏置</span></span><br><span class="line">        biases = bias_variable([output_dim])</span><br><span class="line">        <span class="comment"># 预激活</span></span><br><span class="line">        <span class="comment"># 可以这么翻译，个人认为是激活前的预处理</span></span><br><span class="line">        preactivate = Wx_plus_b(weights, input_tensor, biases)</span><br><span class="line">        <span class="comment"># 若传入了激活函数，则让它激活</span></span><br><span class="line">        <span class="keyword">if</span> act != <span class="literal">None</span>:</span><br><span class="line">            activations = act(preactivate, name=<span class="string">'activation'</span>)</span><br><span class="line">            <span class="keyword">return</span> activations</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 否则就输出预激活量</span></span><br><span class="line">            <span class="keyword">return</span> preactivate</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  conv_pool_layer</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  卷积+池化层，在deepid中一共有3层</span></span><br><span class="line"><span class="string">  也可以定制only_conv=True来满足deepid第四层只有卷积</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  卷积：局部感知，基于相邻部分的相关性原理；权值共享、因此可以设计多核卷积</span></span><br><span class="line"><span class="string">  池化：这里使用最大池化，则说明是提取显著特征</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_pool_layer</span><span class="params">(x, w_shape, b_shape, layer_name, act=tf.nn.relu, only_conv=False)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span><br><span class="line">        W = weight_variable(w_shape)</span><br><span class="line">        b = bias_variable(b_shape)</span><br><span class="line">        <span class="comment"># 输入到卷积层</span></span><br><span class="line">        conv = tf.nn.conv2d(</span><br><span class="line">            <span class="comment"># 输入x和卷积核W的大小、权重</span></span><br><span class="line">            x, W, </span><br><span class="line">            <span class="comment"># 卷积步长，tf中前后两个1不能改，中间两个为水平滑动和垂直滑动步长</span></span><br><span class="line">            strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], </span><br><span class="line">            <span class="comment"># VALID方式丢弃小于窗口大小的</span></span><br><span class="line">            <span class="comment"># SAME方式相反会填充到窗口大小</span></span><br><span class="line">            padding=<span class="string">'VALID'</span>, </span><br><span class="line">            name=<span class="string">'conv2d'</span></span><br><span class="line">        )</span><br><span class="line">        h = conv + b</span><br><span class="line">        <span class="comment"># 加入偏置，激活</span></span><br><span class="line">        relu = act(h, name=<span class="string">'relu'</span>)</span><br><span class="line">        <span class="keyword">if</span> only_conv == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">return</span> relu</span><br><span class="line">        <span class="comment"># 若存在池化层则再进行池化</span></span><br><span class="line">        <span class="comment"># ksize参数确定了池化窗口大小</span></span><br><span class="line">        <span class="comment"># 值得注意的是这里的最大池化没有使用激活函数，也就是仅仅提取线性的显著特征</span></span><br><span class="line">        pool = tf.nn.max_pool(relu, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'VALID'</span>, name=<span class="string">'max-pooling'</span>)</span><br><span class="line">        <span class="keyword">return</span> pool</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  accuracy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  在验证集上测试阶段的准确度计算，由模型预测值和实际值计算得出</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(y_estimate, y_real)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>):</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'correct_prediction'</span>):</span><br><span class="line">            <span class="comment"># 在测试阶段的准确度计算</span></span><br><span class="line">            correct_prediction = tf.equal(tf.argmax(y,<span class="number">1</span>), tf.argmax(y_,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'accuracy'</span>): </span><br><span class="line">            <span class="comment"># 对每个批次计算总的准确度均值</span></span><br><span class="line">            accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br><span class="line">        <span class="comment"># 记录准确度信息</span></span><br><span class="line">        tf.summary.scalar(<span class="string">'accuracy'</span>, accuracy)  </span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  train_step</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  训练梯度，也就是需要计算梯度下降了</span></span><br><span class="line"><span class="string">  这里采用了ADAM优化器，其他优化器的特征：</span></span><br><span class="line"><span class="string">  Momentum冲量算法增加冲量、</span></span><br><span class="line"><span class="string">  Adagrad对低频变化的参数以更大步长更新、</span></span><br><span class="line"><span class="string">  RMSProp更新时只更新梯度平方的期望（移动的均值）</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  ADAM优化器对梯度的一阶矩估计（均值）和二阶矩估计（方差）两个方面适应性调节</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(loss)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span><br><span class="line">        <span class="comment"># 初始学习率1e-4，之后同样会动态调整，一般是逐步衰减，减少趋近最优时的震荡</span></span><br><span class="line">        <span class="comment"># minimize才是更新梯度，之前是计算梯度</span></span><br><span class="line">        <span class="keyword">return</span> tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入，tf.placeholder为形参，在执行时再赋具体的值</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'input'</span>):</span><br><span class="line">    h0 = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">3</span>], name=<span class="string">'x'</span>)</span><br><span class="line">    y_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, class_num], name=<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第1个卷积-池化层，4x4，当前通道数3，卷积核数量（下一层通道数）20，偏置大小20</span></span><br><span class="line">h1 = conv_pool_layer(h0, [<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">20</span>], [<span class="number">20</span>], <span class="string">'Conv_layer_1'</span>)</span><br><span class="line"><span class="comment"># 第2个卷积-池化层，3x3，当前通道数20，卷积核数量40，偏置大小40</span></span><br><span class="line">h2 = conv_pool_layer(h1, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">40</span>], [<span class="number">40</span>], <span class="string">'Conv_layer_2'</span>)</span><br><span class="line"><span class="comment"># 第3个卷积-池化层，3x3，当前通道数40，卷积核数量60，偏置大小60</span></span><br><span class="line">h3 = conv_pool_layer(h2, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">60</span>], [<span class="number">60</span>], <span class="string">'Conv_layer_3'</span>)</span><br><span class="line"><span class="comment"># 第4个卷积层，2x2，当前通道数60，卷积核数量80，偏置大小80</span></span><br><span class="line">h4 = conv_pool_layer(h3, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">60</span>, <span class="number">80</span>], [<span class="number">80</span>], <span class="string">'Conv_layer_4'</span>, only_conv=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后一个deepid层</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'DeepID1'</span>):</span><br><span class="line">    <span class="comment"># deepid层直接与第3层相连，</span></span><br><span class="line">    <span class="comment"># 使用reshape能够拉平这两层的输出为1维数组</span></span><br><span class="line">    <span class="comment"># -1即为任意维，后跟的是每一维度实际尺寸大小，</span></span><br><span class="line">    <span class="comment"># 该大小即为整个层所有神经元个数（比实际还偏大一点），因此是拉平了的</span></span><br><span class="line">    h3r = tf.reshape(h3, [<span class="number">-1</span>, <span class="number">5</span>*<span class="number">4</span>*<span class="number">60</span>])</span><br><span class="line">    <span class="comment"># deepid层与第4层相连</span></span><br><span class="line">    h4r = tf.reshape(h4, [<span class="number">-1</span>, <span class="number">4</span>*<span class="number">3</span>*<span class="number">80</span>])</span><br><span class="line">    <span class="comment"># 初始化两次相连的权重</span></span><br><span class="line">    W1 = weight_variable([<span class="number">5</span>*<span class="number">4</span>*<span class="number">60</span>, <span class="number">160</span>])</span><br><span class="line">    W2 = weight_variable([<span class="number">4</span>*<span class="number">3</span>*<span class="number">80</span>, <span class="number">160</span>])</span><br><span class="line">    b = bias_variable([<span class="number">160</span>])</span><br><span class="line">    <span class="comment"># 直接带权重一起相加</span></span><br><span class="line">    h = tf.matmul(h3r, W1) + tf.matmul(h4r, W2) + b</span><br><span class="line">    <span class="comment"># relu激活</span></span><br><span class="line">    h5 = tf.nn.relu(h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算损失函数</span></span><br><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>):</span><br><span class="line">    <span class="comment"># n*n的全连接层，将拉平的第3、4层全连接到一个160个神经元的全连接层上</span></span><br><span class="line">    y = nn_layer(h5, <span class="number">160</span>, class_num, <span class="string">'nn_layer'</span>, act=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># softmax层</span></span><br><span class="line">    <span class="comment"># 1. 将logits（也就是输入y），计算为（0，1）范围的概率值</span></span><br><span class="line">    <span class="comment"># 2. 计算损失loss，这里计算的是交叉熵损失，y_认为是对应的标签</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">      增加Soft-max layer的输出数量（即分类数，或识别的个体数）可以提升人脸验证的准确率。</span></span><br><span class="line"><span class="string">      即分类的类别数越多，DeepConv-Net学到的DeepID特征（160维）越有效。</span></span><br><span class="line"><span class="string">      此外，作者强调用于人脸验证的一定是160维长度的DeepID特征，而不是Softmax Layer的输出。</span></span><br><span class="line"><span class="string">      如果用SoftmaxLayer输出的结果（例如用4348个不同人的数据训练DeepID,Softmax输出是4348维）</span></span><br><span class="line"><span class="string">      进行人脸验证特征，采用联合贝叶斯人脸验证方法得到的准确率约为66%，而神经网络人脸验证方法则完全失效</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      摘录自：https://www.cnblogs.com/venus024/p/5632243.html</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      笔者（本人）注：可以说这个神经网络只是利用了多分类训练（可以在代码中看出同一个人的类别标签还是相同的）的形式，</span></span><br><span class="line"><span class="string">      训练神经网络在提取特征时的权重参数，从而达到提取特征、加以比对的目的</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits = y, labels = y_))</span><br><span class="line">    <span class="comment"># 记录当前损失</span></span><br><span class="line">    tf.summary.scalar(<span class="string">'loss'</span>, loss)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化精确度</span></span><br><span class="line">accuracy = accuracy(y, y_)</span><br><span class="line"><span class="comment"># 初始化优化器</span></span><br><span class="line">optimizer = train_step(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并所有的记录，给session用来回调运行</span></span><br><span class="line">merged = tf.summary.merge_all()  </span><br><span class="line"><span class="comment"># 保存模型的回调</span></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  训练主函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取一个batch的输入</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_batch</span><span class="params">(data_x, data_y, start)</span>:</span></span><br><span class="line">        end = (start + <span class="number">1024</span>) % data_x.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> start &lt; end:</span><br><span class="line">            <span class="keyword">return</span> data_x[start:end], data_y[start:end], end</span><br><span class="line">        <span class="keyword">return</span> np.vstack([data_x[start:], data_x[:end]]), np.vstack([data_y[start:], data_y[:end]]), end</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        <span class="comment"># 注意，trainX和trainY为具体数据和标签</span></span><br><span class="line">        data_x = trainX</span><br><span class="line">        data_y = (np.arange(class_num) == trainY[:,<span class="literal">None</span>]).astype(np.float32)</span><br><span class="line">        validY = (np.arange(class_num) == validY[:,<span class="literal">None</span>]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 日志文件目录</span></span><br><span class="line">        logdir = <span class="string">'/content/drive/My Drive/Colab Notebooks/deepid/log'</span></span><br><span class="line">        <span class="keyword">if</span> tf.gfile.Exists(logdir):</span><br><span class="line">            tf.gfile.DeleteRecursively(logdir)</span><br><span class="line">        tf.gfile.MakeDirs(logdir)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建训练线程</span></span><br><span class="line">        sess = tf.Session()</span><br><span class="line">        <span class="comment"># 初始化所有参数，开始训练</span></span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        <span class="comment"># 写入训练日志和测试日志</span></span><br><span class="line">        train_writer = tf.summary.FileWriter(logdir + <span class="string">'/train'</span>, sess.graph)</span><br><span class="line">        test_writer = tf.summary.FileWriter(logdir + <span class="string">'/test'</span>, sess.graph)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始训练，训练次数50000次</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50001</span>):</span><br><span class="line">            <span class="comment"># 获取一个batch的输入</span></span><br><span class="line">            batch_x, batch_y, idx = get_batch(data_x, data_y, idx)</span><br><span class="line">            <span class="comment"># 优化器</span></span><br><span class="line">            _ = sess.run(optimizer, &#123;h0: batch_x, y_: batch_y&#125;)</span><br><span class="line">            <span class="comment"># 运行，h0赋值为batchX，也就是图像，y_赋值为batch_y，也就是标签</span></span><br><span class="line">            summary = sess.run(merged, &#123;h0: batch_x, y_: batch_y&#125;)</span><br><span class="line"></span><br><span class="line">            train_writer.add_summary(summary, i)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每100次进行验证集测试</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                summary = sess.run(merged, &#123;h0: validX, y_: validY&#125;)</span><br><span class="line">                test_writer.add_summary(summary, i)</span><br><span class="line">            <span class="comment"># 每5000次保存一次模型</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">5000</span> == <span class="number">0</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">                saver.save(sess, <span class="string">'/content/drive/My Drive/Colab Notebooks/deepid/checkpoint/%05d.ckpt'</span> % i)</span><br></pre></td></tr></table></figure>
<p>这里展示一下tensorboard采集的使用TPU（由于速度过慢，未训练完）和Tesla T4 GPU（2小时训练结束）的进行50000次训练的准确率和损失率图表：</p>
<p>对于TPU：</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/TPU-acc.png" alt="TPU-acc"></p>
<center>图2.4 TPU训练时的准确度统计图</center>

<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/TPU-acc-1.png" alt="TPU-acc-1"></p>
<center>图2.5 TPU训练时的准确度与耗时（放大后）</center>

<p>可以看出TPU训练时的准确度上升缓慢，而且过了3个小时后，准确度仍然在0.6，而且才训练了不到4k次。</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/TPU-loss.png" alt="TPU-loss"></p>
<center>图2.6 TPU训练时的损失率统计图</center>

<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/TPU-loss-1.png" alt="TPU-loss-1"></p>
<center>图2.7 TPU训练时的损失率与耗时（放大后）</center>

<p>同样地，TPU训练时损失率下降也十分缓慢。</p>
<p>对于GPU：</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/GPU-acc.png" alt="GPU-acc"></p>
<center>图2.8 GPU训练时的准确度统计图</center>

<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/GPU-acc-1.png" alt="GPU-acc-1"></p>
<center>图2.9 GPU训练时的准确度与耗时（放大后）</center>

<p>可以看出TPU训练时的准确度上升呈对数曲线，在训练次数到15k~30k时就已经趋于稳定，在1小时27分时就已经结束了训练。</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/GPU-loss.png" alt="GPU-loss"></p>
<center>图2.10 GPU训练时的损失率统计图</center>

<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/GPU-loss-1.png" alt="GPU-loss"></p>
<center>图2.10 GPU训练时的损失率与耗时（放大后）</center>

<p>同样地，GPU训练时损失率下降也十分迅速。</p>
<p>综上，可以看出Google Colab提供的免费GPU性能十分地强劲，能够满足快速训练简单的深度学习模型的需求。这款GPU通过nvidia-smi命令查询的情况如下所示，据查，该款显卡的价格约两万元人民币，可以看出谷歌为了推广深度学习付出了巨大的成本。</p>
<p><img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/nvidia-smi.png" alt="nvidia-smi"></p>
<center>图2.11 nvidia-smi命令得到的GPU信息：Tesla T4</center>

<h4 id="在测试集上使用模型文件预测，获取余弦距离阈值"><a href="#在测试集上使用模型文件预测，获取余弦距离阈值" class="headerlink" title="在测试集上使用模型文件预测，获取余弦距离阈值"></a>在测试集上使用模型文件预测，获取余弦距离阈值</h4><p>这里运行测试集除了检验模型的预测效果，更重要的是获取余弦距离的阈值，也就是<code>(true_mean + false_mean)/2</code>，意思是：小于同类组+不同类组的平均组内距离的两者平均（有点拗口，但是确实是以此为阈值）。根据这个阈值，就能判断任意两个人脸之间的距离代表的是同一个人还是不同的人。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  predict.py</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  预测模块，训练结束后即可使用模型文件预测</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cosine, euclidean</span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  predict</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  预测</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(ckpt)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        saver.restore(sess, ckpt)</span><br><span class="line">        <span class="comment"># 计算测试集的两对数据特征值列表</span></span><br><span class="line">        h1 = sess.run(h5, &#123;h0: testX1&#125;)</span><br><span class="line">        h2 = sess.run(h5, &#123;h0: testX2&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算两个特征值列表对应两项的余弦距离</span></span><br><span class="line">    <span class="comment"># 事实上是1-余弦距离，距离越近，数值越小，符合直觉</span></span><br><span class="line">    <span class="comment"># 因此范围也从-1~1变为了0~2</span></span><br><span class="line">    pre_y = np.array([cosine(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(h1, h2)])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 求余弦距离阈值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">part_mean</span><span class="params">(x, mask)</span>:</span></span><br><span class="line">        <span class="comment"># mask事实上是测试集的标签，若是testY，1就代表对应的两张图为同类，0为不同类，1-testY反之</span></span><br><span class="line">        <span class="comment"># 以testY为例，在这一乘法下，留下的非零项目即为同类项</span></span><br><span class="line">        z = x * mask</span><br><span class="line">        <span class="comment"># 同类组余弦距离总和/同类组数量</span></span><br><span class="line">        <span class="comment"># 对所有非零项目求和=同类组距离总和</span></span><br><span class="line">        <span class="comment"># 非零项目个数=同类组数量</span></span><br><span class="line">        <span class="comment"># 两者相除则为同类组的平均组内距离</span></span><br><span class="line">        <span class="comment"># 1-testY时则为不同类组的平均组内距离</span></span><br><span class="line">        <span class="keyword">return</span> float(np.sum(z) / np.count_nonzero(z))</span><br><span class="line">    </span><br><span class="line">    true_mean = part_mean(pre_y, testY)</span><br><span class="line">    false_mean = part_mean(pre_y, <span class="number">1</span>-testY)</span><br><span class="line">    print(true_mean, false_mean)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 筛选出pre_y也就是余弦距离结果中，符合小于同类组+不同类组的平均组内距离的两者平均这一条件的项目，与testY中的对应项目进行比对</span></span><br><span class="line">    <span class="comment"># 由于testY中对应项目为1也就是True的元素代表两张图为同类，因此当pre_y中元素小于这一条件时，也代表为同类</span></span><br><span class="line">    <span class="comment"># 反之，pre_y中的元素大于这一条件时，代表非同类</span></span><br><span class="line">    <span class="comment"># 所以最终得到的矩阵是一个同类、非同类的预测值与测试集标签之间的对应关系，只有正确的才能留下来</span></span><br><span class="line">    <span class="comment"># 对此计算均值，即可获取模型在测试集上的准确率</span></span><br><span class="line">    print(np.mean((pre_y &lt; (true_mean + false_mean)/<span class="number">2</span>) == testY.astype(bool)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    预测主函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 输入模型路径</span></span><br><span class="line">    predict(<span class="string">'/content/drive/My Drive/Colab Notebooks/deepid/checkpoint/30000.ckpt'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="预测服务搭建"><a href="#预测服务搭建" class="headerlink" title="预测服务搭建"></a>预测服务搭建</h3><p>对于已经训练好的Tensorflow模型的预测服务搭建，在网络上有许多的方法，事实上最好的方法是使用frozen_graph工具对checkpoint进行固化处理，笔者这里是直接调用了checkpoint来恢复现场，事实上效果类似。<br>笔者在这里使用的是docker进行预测服务搭建，具体使用的镜像是<code>yoanlin/opencv-python3-tensorflow</code>，自带python3、opencv和tensorflow1.x。由于tensorflow仅仅是使用1.14生成的模型，所以不存在兼容性问题。<br>具体命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker pull yoanlin/opencv-python3-tensorflow</span><br><span class="line"><span class="comment"># 生成容器，配置端口映射和文件夹映射</span></span><br><span class="line"><span class="comment"># 8888端口是tensorboard，8080是flask</span></span><br><span class="line"><span class="comment"># faces文件夹映射为人脸图像路径，我是使用软工项目中的Spring boot来接收图像的，所以flask就没写接收代码，直接从文件路径里面取，server文件夹映射为flask的程序文件</span></span><br><span class="line">docker run -itd --name=tf-cv -p 7777:8888 -p 8081:8080 -v /tf-cv/faces:/faces -v /tf-cv/server/:/server yoanlin/opencv-python3-tensorflow</span><br><span class="line"><span class="comment"># 若需要进入镜像内部安装flask等其他python库，运行以下命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tf-cv bash</span><br><span class="line"><span class="comment"># flask无法独立启动守护进程，需要使用gunicorn，其中gunicorn.conf.py写有基本配置，此处可自行搜索相关教程</span></span><br><span class="line">gunicorn app:app -c gunicorn.conf.py -D</span><br></pre></td></tr></table></figure>
<p>若需要部署到服务器，可以使用以下命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将容器提交为新的镜像</span></span><br><span class="line">docker commit tf-cv tf-cv:server</span><br><span class="line"><span class="comment"># 将新的镜像打包为tar压缩文件，之后用scp命令传到服务器上</span></span><br><span class="line">docker save &gt; tf-cv.tar tf-cv:server</span><br><span class="line"><span class="comment"># 在服务器上解压镜像</span></span><br><span class="line">docker load &lt; tf-cv.tar</span><br><span class="line"><span class="comment"># 再次使用docker run命令生成新的容器，并在新的容器内部运行flask，参见以上命令</span></span><br></pre></td></tr></table></figure></p>
<h3 id="编写预测代码"><a href="#编写预测代码" class="headerlink" title="编写预测代码"></a>编写预测代码</h3><h4 id="OpenCV人脸检测"><a href="#OpenCV人脸检测" class="headerlink" title="OpenCV人脸检测"></a>OpenCV人脸检测</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  HAAR特征检测人脸</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  用opencv的方式（HAAR特征）检测人脸，效果不是很好。</span></span><br><span class="line"><span class="string">  最优方案是MTCNN，需要人脸特征点数据集多次训练，比较繁琐</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_face</span><span class="params">(img_path)</span>:</span></span><br><span class="line">    <span class="comment"># 获取训练好的人脸参数数据，此处引用GitHub上的opencv库中的默认值</span></span><br><span class="line">    face_cascade = cv2.CascadeClassifier(<span class="string">r'/root/haarcascade_frontalface_default.xml'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取图片，并处理成灰度图</span></span><br><span class="line">    image = cv2.imread(img_path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 未读取到图片，返回</span></span><br><span class="line">    <span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"提示：未读取到图片"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换为灰度图像</span></span><br><span class="line">    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># haar模型检测人脸</span></span><br><span class="line">    faces = face_cascade.detectMultiScale(</span><br><span class="line">        gray,</span><br><span class="line">        scaleFactor = <span class="number">1.15</span>,</span><br><span class="line">        minNeighbors = <span class="number">5</span>,</span><br><span class="line">        minSize = (<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">        flags = cv2.CASCADE_SCALE_IMAGE</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 未检测到人脸，返回</span></span><br><span class="line">    <span class="keyword">if</span> len(faces) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"提示：未检测到人脸"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 裁剪人脸图像</span></span><br><span class="line">    face_images = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">        face_img = image[y:y+h, x:x+w]</span><br><span class="line">        face_images.append(face_img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若有多个人脸，则选出面积最大（也就是最靠前）的人脸</span></span><br><span class="line">    face_images = sorted(face_images, key=<span class="keyword">lambda</span> img:img.size, reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换图像</span></span><br><span class="line">    face = Image.fromarray(face_images[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 缩放为（55，47）</span></span><br><span class="line">    resize_face = face.resize((<span class="number">47</span>,<span class="number">55</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 转换为array</span></span><br><span class="line">    <span class="keyword">return</span> np.asarray(resize_face)</span><br></pre></td></tr></table></figure>
<h4 id="Tensorflow人脸特征比对"><a href="#Tensorflow人脸特征比对" class="headerlink" title="Tensorflow人脸特征比对"></a>Tensorflow人脸特征比对</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import tensorflow as tf</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> detector <span class="keyword">as</span> dt</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> cosine</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  预测</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(src_img_path, dst_img_path)</span>:</span></span><br><span class="line">    <span class="comment"># 对输入的图像分别检测人脸</span></span><br><span class="line">    src_image = dt.detect_face(src_img_path)</span><br><span class="line">    dst_image = dt.detect_face(dst_img_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若返回了错误信息，不再检测</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(src_image, str):</span><br><span class="line">        <span class="keyword">return</span> src_image</span><br><span class="line">    <span class="keyword">elif</span> isinstance(dst_image, str):</span><br><span class="line">        <span class="keyword">return</span> dst_image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 载入tensorflow模型，开始检测</span></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">        saver=tf.train.import_meta_graph(<span class="string">'/root/50000.ckpt.meta'</span>)</span><br><span class="line">        saver.restore(sess,<span class="string">"/root/50000.ckpt"</span>)</span><br><span class="line">        graph = tf.get_default_graph()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算160维的人脸特征</span></span><br><span class="line">        h1 = sess.run(<span class="string">"DeepID1/Relu:0"</span>, feed_dict=&#123;<span class="string">"input/x:0"</span>: [src_image]&#125;)</span><br><span class="line">        h2 = sess.run(<span class="string">"DeepID1/Relu:0"</span>, feed_dict=&#123;<span class="string">"input/x:0"</span>: [dst_image]&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算人脸之间的余弦距离（事实上是1-余弦），范围0~1，越小越接近</span></span><br><span class="line">        pre_y = np.array([cosine(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(h1, h2)])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在测试集上测试模型的过程中，得到了余弦距离的阈值为0.47189</span></span><br><span class="line">        <span class="comment"># 因此，比该阈值小的即为同一个人，大的则不是同一个人</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="string">'msg'</span>: &#123; <span class="string">'isSame'</span>: bool((pre_y &lt; <span class="number">0.47189</span>)[<span class="number">0</span>]), <span class="string">'predict'</span>: pre_y[<span class="number">0</span>] &#125; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Flask后端服务器主程序"><a href="#Flask后端服务器主程序" class="headerlink" title="Flask后端服务器主程序"></a>Flask后端服务器主程序</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> predict.main <span class="keyword">import</span> predict</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/face', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    data = json.loads(request.get_data(as_text=<span class="literal">True</span>))</span><br><span class="line">    src_face = data[<span class="string">'src_face'</span>]</span><br><span class="line">    dst_face = data[<span class="string">'dst_face'</span>]</span><br><span class="line">    res = predict(src_face, dst_face)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回一下两个人脸图像的路径，便于验证是否正确</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(res, str):</span><br><span class="line">      <span class="keyword">return</span> jsonify(&#123; <span class="string">'success'</span>: <span class="literal">False</span>, <span class="string">'msg'</span>: res, <span class="string">'src_face'</span>: src_face, <span class="string">'dst_face'</span>: dst_face &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> jsonify(&#123; <span class="string">'success'</span>: <span class="literal">True</span>, <span class="string">'msg'</span>: res[<span class="string">'msg'</span>], <span class="string">'src_face'</span>: src_face, <span class="string">'dst_face'</span>: dst_face &#125;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>以上的flask服务器的业务流程是：</p>
<ul>
<li>在主程序中路由<code>/face</code>上接收POST请求，收到待比对的两张人脸图片的文件路径。</li>
<li>在detect_face函数中，使用OpenCV的HAAR模型，检测图片中的人脸，并且裁剪成当时训练时使用的(55,47)尺寸输入。若检测不到人脸，或者图片文件无法找到，直接返回错误信息。</li>
<li>在predict函数中，调用tensorflow恢复（restore）模型的参数，输入这两张人脸，获取每张人脸的特征值，计算两者特征值的余弦距离，与之前在测试集上获取的余弦距离阈值进行比对，判断出是否为同一个人，返回结果。</li>
</ul>
<p>最终，在前端小程序的手机前置摄像头调用和用户界面的配合下，该系统的最终效果如下所示：</p>
<p>  <img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/weapp-1.jpeg" alt="weapp-1"><br>  <center>图2.12 地图定位界面</center><br>  <img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/weapp-2.jpeg" alt="weapp-2"><br>  <center>图2.13 人脸识别成功，正在比对人脸</center><br>  <img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/weapp-3.jpeg" alt="weapp-3"><br>  <center>图2.14 未检测到人脸</center><br>  <img src="/2019/06/29/Training-DeepID1-Network-for-Face-Comparison-with-Google-Colab-Tensorflow/weapp-4.jpeg" alt="weapp-4"><br>  <center>图2.15 比对人脸为同一人后，打卡成功的结果</center></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次项目实践了使用OpenCV、Tensorflow、Tensorboard以及docker、Jupyter Notebook等深度学习模型训练的常用工具，并尝试将训练得出的模型进行Python flask后端+小程序前端应用落地。在这一过程中，笔者不但熟悉了从数据集预处理、模型训练框架搭建、模型训练过程监控再到模型实际应用的全过程，也通过编写中文注释、以及对Tensorflow不同版本API的移植重写，进一步熟悉深度学习的常用术语和内在含义，可以说是一次收获颇丰的实践案例。</p>
<p>在此，特别感谢Google Colab免费提供的Nvidia GTX Tesla T4高性能GPU硬件资源以及在线训练平台，感谢他们为深度学习的推广和应用做出的无数努力和贡献。最后，感谢USTB的《机器学习》（自动化学院）、《人工智能》、《模式识别》、《软件工程》等相关课程老师的辛勤教学，是各位老师传授的宝贵知识和设置的一系列大作业帮助着我进一步理解、学习AI各个方向的知识并加以实践，为未来的研究和工作打下了知识基础。感谢大家！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>GitHub上DeepID的Tensorflow实现（本文在此基础上修改了调用的TensorflowAPI到1.14，并添加中文注释）：<br><a href="https://github.com/jinze1994/DeepID1" target="_blank" rel="noopener">https://github.com/jinze1994/DeepID1</a></li>
<li>DeepID1论文《Deep Learning Face Representation from Predicting 10,000 Classes》：<br><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Sun_Deep_Learning_Face_2014_CVPR_paper.pdf" target="_blank" rel="noopener">https://www.cv-foundation.org/openaccess/content_cvpr_2014/papers/Sun_Deep_Learning_Face_2014_CVPR_paper.pdf</a></li>
<li>Google Colab官网：<a href="https://colab.research.google.com" target="_blank" rel="noopener">https://colab.research.google.com</a></li>
<li>DeepID1、2算法解读：<a href="https://www.cnblogs.com/venus024/p/5632243.html" target="_blank" rel="noopener">https://www.cnblogs.com/venus024/p/5632243.html</a></li>
<li>人脸特征提取DeepID 1.0深度网络解读：<br><a href="https://blog.csdn.net/jiajinrang93/article/details/72566130/" target="_blank" rel="noopener">https://blog.csdn.net/jiajinrang93/article/details/72566130/</a></li>
</ol>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Different Deep Learning Methods for Image Classification on CIFAR 10</title>
    <url>/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/</url>
    <content><![CDATA[<p>本文是2019年4月《人工智能》专业课的大作业报告摘录</p>
<p>主要内容是在同一数据集（CIFAR10）上使用不同的卷积神经网络模型<br>进行多分类问题训练以及识别效果的横向评估</p>
<a id="more"></a>
<blockquote>
<p>中文标题：基于不同神经网络的CIFAR10图像分类</p>
</blockquote>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/aistudio.png" alt="AI Studio"></p>
<center>图1.1 本次实验的AI Studio项目入口页面</center>

<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><ol>
<li><a href="https://aistudio.baidu.com/aistudio/#/projectdetail/56694" target="_blank" rel="noopener">百度 AI Studio</a>（需要登录AI Studio账号后访问，使用百度账号即可）</li>
<li>在AI Studio的“开发者共享项目”中搜索“CIFAR10图像”分类即可</li>
<li>GitHub（待发布）</li>
</ol>
<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ol>
<li><p>基于百度AI Studio平台提供的paddlepaddle深度学习框架、Jupyter Notebook线上python运行环境等基础设施，编程实现包括VGG、ResNet、GoogleNet（Inception-V1）、Inception-V4等多种图像分类神经网络。在编程实现的过程中，学习深度神经网络的基本理论和实践要点，了解上述不同神经网络的具体结构设计以及体现出的优秀设计理念和不足之处。</p>
</li>
<li><p>使用平台提供的CIFAR10图像识别数据集，在相同的训练环境条件下，训练上述不同神经网络并得出数据模型。收集训练模型过程中输出的训练参数数据，绘制统计图表，比较分析不同神经网络模型的在训练过程中的性能开销、数据指标变化等特点。</p>
</li>
<li><p>通过统一的测试图像对训练得出的模型分类图像内容的准确性进行测试，从而比较分析不同神经网络模型在实际应用中的效果。</p>
</li>
</ol>
<blockquote>
<p>笔者注：根据最后的评估结果以及对相关论文、资料的研读，我们发现这种类似单一变量法的横向对比实验事实上是存在问题的：</p>
<p>不同年代的卷积神经网络模型，对于训练时最佳效果的硬件要求应该是不同的，虽然不排除存在出现轻量级框架的可能，但是主流意义上的框架对于硬件资源的需求的确是逐年上升的。不应当对每一种模型在训练过程中给出相同的硬件环境，而是给出文献或其开源代码所要求的最佳硬件环境。</p>
<p>因此，本次实验出现的较新版本的模型最终的识别效果较差的情况，事实上仅仅是实验平台的硬件条件不足以在短时间内训练得出最佳效果的模型。</p>
</blockquote>
<h3 id="实验仪器"><a href="#实验仪器" class="headerlink" title="实验仪器"></a>实验仪器</h3><ul>
<li>本地设备：华硕K550-JX笔记本电脑、macOS Mojave 10.14.4</li>
<li>远程设备：百度AI Studio提供的通过Jupyter Notebook连接的CPU: 2 Cores 、Memory: 8GB的远程服务器（无GPU）</li>
</ul>
<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><h4 id="实验项目概况"><a href="#实验项目概况" class="headerlink" title="实验项目概况"></a>实验项目概况</h4><p>本次实验的基本框架来自于paddlepaddle官网教程中的《深度学习基础教程》的《图像分类》章节（网页链接：<a href="http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html）。" target="_blank" rel="noopener">http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html）。</a></p>
<p>该章节介绍了图像识别分类领域中包括VGG、ResNet和GoogleNet等常用模型的基本原理，并给出了paddlepaddle使用其框架自带的CIFAR10数据集以及VGG、ResNet训练模型并进行图像分类的基本步骤和代码实现。</p>
<p>我们在研读了该教程中的相关理论知识、各行代码实现的前提下，将该教程所述的数据预处理、训练模型、图像识别等完整的流程代码，移植到了同样搭载了最新版本的paddlepaddle的AI Studio在线项目环境中。该项目为新建的项目，而非直接fork在AI Studio上现有的项目，因此能够使用最新版本的paddlepaddle，避免了fork使用早期paddlepaddle版本项目所带来的一系列问题。</p>
<p>除此之外，我们也对代码进行了逐行的注释解读工作，来帮助使用者理解代码的基本含义和相关的理论知识。我们添加了训练过程中的数据统计图表绘制功能代码，能够在训练结束后将收集到的训练数据绘制成形象的图表并输出，有助于使用者对不同模型的性能进行综合的判断。</p>
<p>在此基础之上，我们更进一步，参考网络上的相关资料，将该教程中仅给出理论知识而无代码实践的GoogleNet（Inception-V1）、以及其同一系列的最新版本Inception-V4的模型代码移植实现到了百度AI Studio在线项目环境上（由于部分代码存在版本过低等问题，我们进行了相应的修改以确保代码能够正常运行），同样给出了详尽的代码注释解读。</p>
<p>现在，本项目已经公开在了百度AI Studio的“开发者共享项目”栏目中，欢迎大家fork本项目，也欢迎大家联系我们（邮箱：<a href="mailto:lmy98129@163.com" target="_blank" rel="noopener">lmy98129@163.com</a>）提出建议。</p>
<h4 id="CIFAR数据集介绍"><a href="#CIFAR数据集介绍" class="headerlink" title="CIFAR数据集介绍"></a>CIFAR数据集介绍</h4><blockquote>
<p>注：以下实验原理介绍部分摘录自paddlepaddle官方教程以及其他网络资料，同时也添加了我们在理论学习和实践过程中对于数据集使用、神经网络模型设计的优缺点等方面的思考和理解，能力有限，如有偏差，敬请谅解。</p>
</blockquote>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/cifar.png" alt="cifar"></p>
<center>图1.2 CIFAR数据集局部<br>（图片摘自paddlepaddle官方教程）</center>

<p>CIFAR10数据集是主要用于通用图像分类而公开的标准数据集CIFAR的一个子集，包含60,000张32x32的彩色图片，10个类别（分别为：飞机airplane、轿车automobile、鸟类bird、猫cat、鹿deer、狗dog、蛙frog、马horse、船ship、卡车truck），每个类包含6,000张。其中50,000张图片作为训练集，10000张作为测试集。</p>
<p>之所以选用CIFAR而不是大量学术研究成果所基于的ImageNet，我们主要考虑到其体积的问题，在AI Studio的在线项目环境中使用的是CPU训练，而CPU的训练速度由于其核心数量、并行计算能力等原因一般要远远慢于GPU，因此选择一个较小的数据集能够较好地节省训练的时间，但也因此对模型的在小数据集条件下的训练效果提出了考验。</p>
<p>关于下载速度，由于AI Studio提供了可动态加载的数据集仓库，能够通过创建项目时进行设置、或者创建后修改项目设置等方式动态加载到项目中，因此不存在联网下载的问题。</p>
<h4 id="VGG基本介绍"><a href="#VGG基本介绍" class="headerlink" title="VGG基本介绍"></a>VGG基本介绍</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/vgg.png" alt="vgg"></p>
<center>图1.3 VGG模型结构<br>（图片摘自paddlepaddle官方教程）</center>

<p>相比以往的神经网络模型（例如CNN等），由牛津大学于2014年提出的VGG模型在神经网络的层数（深度）和卷积层的卷积核数目（宽度）上进行了增加。其核心结构是：五组不同卷积核数目的卷积层，以及每两组卷积层之间的max-pooling最大池化的降维操作，最后是全连接层和分类预测层。</p>
<p>关于VGG网络的设计，我们认为，加深神经网络能够进行更多次的特征提取，提高神经网络的表达能力，但是也增加了训练神经网络的时间和成本，过深的神经网络往往会因为带来梯度的损失而无法找到最优解，从而导致过拟合、准确度下降等一系列问题；加宽的神经网络能够输入更多的细节特征，但也导致了需要输入的参数过多，而同等深度下的神经网络，参数的个数对训练的结果没有明显的影响。</p>
<h4 id="ResNet基本介绍"><a href="#ResNet基本介绍" class="headerlink" title="ResNet基本介绍"></a>ResNet基本介绍</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/resnet.png" alt="resnet"></p>
<center>图1.4 残差模块示意图<br>（图片摘自paddlepaddle官方教程）</center>

<p>为了解决随着网络层数加深而导致准确度下降的问题，ResNet提出了残差学习方法来减轻训练深层网络的困难，在添加batchnorm、小卷积核、全卷积网络等特性基础上，引入了残差模块。</p>
<p>残差模块的其中一条路径是输入特征的直连通道（可以认为是输入特征中的普遍特征），另一条经过多次卷积的到特征的残差（可以认为是输入特征中的显著特征），最后将以上两条结果相加得到输出。通过这种输出的叠加，残差模块很好地提升了深层次网络训练结果的准确度和收敛速度。</p>
<p>我们对于以上提到的一些现有特性概念的理解是：batchnorm能够将每次输入的数据分布进行规范化，让其均匀分布在当前层上，从而加速神经网络的训练速度、防止过拟合。小卷积核的意思是指单个卷积核的长宽尺寸减小，能够减少训练参数，从而降低训练模型的性能开销。全卷积网络是指整个模型的主体部分完全使用卷积网络，全连接层使用增加步长的特定卷积层替换，这种替换在功能上是等价的。</p>
<h4 id="GoogleNet（Inception-V1）基本介绍"><a href="#GoogleNet（Inception-V1）基本介绍" class="headerlink" title="GoogleNet（Inception-V1）基本介绍"></a>GoogleNet（Inception-V1）基本介绍</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/googlenet.png" alt="googlenet"></p>
<center>图1.5 Inception模块示意图<br>右图为添加1*1卷积层进行降维之后的模块<br>（图片摘自paddlepaddle官方教程）</center>

<p>GoogleNet由多组Inception模块组成，Inception模块的主要特点是在同一层级上并行设置了多个不同尺寸的卷积层和一个最大池化层，根据资料以及我们的理解总结，这一特性解决了多个问题：</p>
<ol>
<li>卷积层的不同尺寸消除了信息分布的均匀程度对卷积核大小的选取影响 </li>
<li>并行的卷积层减缓了网络层数过深导致的梯度损失以及过拟合</li>
<li>并行的最大池化层对输入尺寸进行压缩并提取主要特征，也缓解了简单堆叠多层网络导致的计算资源的消耗 </li>
</ol>
<p>但是这个特点同样带来了缺陷：并行的池化层并不会改变整个Inception模块的通道数量，并行卷积层构成的Inception在将各个并行层结果拼接后，特征的通道数较大，经过几层这样的模块堆积后，通道数会越来越大，导致参数和计算量也随之增大。因此，Inception还在每一个并行分支上引入了1*1卷积层进行降维操作，减少通道数，解决了这一问题。</p>
<p>除此之外，GoogleNet的另一个显著特征就是采用了三个子网络，可以得到3个网络的损失率进行加权求和得出整个网络的损失，从而有利于使用优化器（optimizer）的训练程序计算更准确的梯度，加快收敛速度。</p>
<h4 id="Inception-V4基本介绍"><a href="#Inception-V4基本介绍" class="headerlink" title="Inception-V4基本介绍"></a>Inception-V4基本介绍</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/inception-v4.png" alt="inception-v4"></p>
<center>图1.6 inception-sterm模块示意图<br>（图片摘自论文《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》）<br></center>

<p>Inception-V4是Inception系列中的最新版本，经过V2版本添加batchnorm，V3版本对卷积层的调整，在Inception-V4中加入了同样基于卷积+池化并行理念的inception-sterm模块，并分化出了inception-A、B、C三种不同的模块类型。其设计的理念是要与添加了残差模块的Inception-ResNet具有相同的性能，因此使用了大量的经验性的结构设计，其对应的论文中没有对这些结构设计的由来做出进一步的解释说明。</p>
<p>此外，该模型还添加了reduction模块，起到了之前版本中的一层单层池化层的作用，同样采用了卷积+池化并行的结构设计。</p>
<h3 id="实验内容与步骤"><a href="#实验内容与步骤" class="headerlink" title="实验内容与步骤"></a>实验内容与步骤</h3><h4 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h4><h5 id="登录AI-Studio平台"><a href="#登录AI-Studio平台" class="headerlink" title="登录AI Studio平台"></a>登录AI Studio平台</h5><p>登录百度AI Studio首页并登录AI Studio账号，选择顶部导航栏中的“项目”，进入项目页面</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/init-step1.png" alt="登录 AI Studio"></p>
<center>图2.1 登录百度AI Studio进入AI Studio的项目页面</center>

<h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><p>点击“创建项目”，输入项目名称、描述并添加数据集。在数据集添加界面中搜索并选中“cifar10数据集”。这里之所以选择这一项“cifar10数据集”是因为该数据集与在调用paddlepaddle自带的cifar10数据集时需要自动联网下载的cifar10数据集格式相同，可以在项目建立后通过在Jupyter Notebook中执行shell命令的方式，将数据集自行放入paddlepaddle的缓存目录中，节省其下载时间。</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/init-step2-1.png" alt="创建项目"></p>
<center>图2.2 创建项目界面</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/init-step2-2.png" alt="选择数据集"></p>
<center>图2.3 选择“cifar10数据集”</center>

<h5 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h5><p>创建项目之后，进入项目界面，点击“运行项目”，进入Jupyter Notebook界面</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/init-step3.png" alt="Jupyter Notebook"></p>
<center>图2.4 Jupyter Notebook界面</center>

<h5 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h5><p>在第一个cell中输入将当前自动载入到项目当中的数据集cifar-10-python.tar.gz拷贝到paddlepaddle缓存目录的shell命令，如下所示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!cp data/data5752/cifar-10-python.tar.gz /home/aistudio/.cache/paddle/dataset/cifar/cifar-10-python.tar.gz</span><br><span class="line">!ls -l /home/aistudio/.cache/paddle/dataset/cifar/</span><br></pre></td></tr></table></figure>
<p>执行该cell，若得到如下输出，则拷贝成功。</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/init-step4.png" alt="拷贝数据集"></p>
<center>图2.5 拷贝数据集成功的输出</center>

<p>至此，项目初始化完成。</p>
<h4 id="编写项目主体代码"><a href="#编写项目主体代码" class="headerlink" title="编写项目主体代码"></a>编写项目主体代码</h4><h5 id="导入系统模块代码"><a href="#导入系统模块代码" class="headerlink" title="导入系统模块代码"></a>导入系统模块代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入paddle模块以及一些系统模块</span></span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.param_attr <span class="keyword">import</span> ParamAttr</span><br></pre></td></tr></table></figure>
<p>如上所示，这些代码的主要导入了包括paddlepaddle、numpy、sys、math等运行环境内置的python库。</p>
<h5 id="训练模型所需的模块函数"><a href="#训练模型所需的模块函数" class="headerlink" title="训练模型所需的模块函数"></a>训练模型所需的模块函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_network</span><span class="params">(model)</span>:</span></span><br><span class="line">    <span class="comment"># 图像是32 * 32的rgb格式，rgb格式每个像素应该是3位</span></span><br><span class="line">    data_shape = [<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>]</span><br><span class="line">    <span class="comment"># 设置图片格式</span></span><br><span class="line">    images = fluid.layers.data(name=<span class="string">'pixel'</span>, shape=data_shape, dtype=<span class="string">'float32'</span>)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'vgg'</span>:</span><br><span class="line">    <span class="comment"># 使用vgg模型进行预测</span></span><br><span class="line">        predict = vgg_bn_drop(images)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'resnet'</span>:</span><br><span class="line">    <span class="comment"># 使用resnet模型进行预测</span></span><br><span class="line">        predict = resnet_cifar10(images, <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'googlenet'</span>:</span><br><span class="line">    <span class="comment"># 使用googlenet模型进行预测</span></span><br><span class="line">        predict = googlenet(images, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'inception_v4'</span>:</span><br><span class="line">    <span class="comment"># 使用inception_v4模型进行预测</span></span><br><span class="line">        inception_v4 = InceptionV4()</span><br><span class="line">        predict = inception_v4.net(images, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure>
<p>预测程序是在训练或预测过程中实际调用各神经网络模型的最底层函数，这里可以看到不同的模型要求输入的参数类型、调用方式都各有不同。这些模型的具体实现代码在下文会详细给出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_network</span><span class="params">(predict, model=None)</span>:</span></span><br><span class="line">    <span class="comment"># 首先从预测程序中获取预测结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置图片类别标签格式</span></span><br><span class="line">    label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'googlenet'</span>:</span><br><span class="line">        <span class="comment"># 若为googlenet</span></span><br><span class="line">        out, out1, out2 = predict</span><br><span class="line">        <span class="comment"># 分别采用多类交叉熵作为损失函数</span></span><br><span class="line">        cost0 = fluid.layers.cross_entropy(input=out, label=label)</span><br><span class="line">        cost1 = fluid.layers.cross_entropy(input=out1, label=label)</span><br><span class="line">        cost2 = fluid.layers.cross_entropy(input=out2, label=label)</span><br><span class="line">        <span class="comment"># 得到的平均损失用于在上一层中的训练主函数中计算梯度</span></span><br><span class="line">        avg_cost0 = fluid.layers.mean(x=cost0)</span><br><span class="line">        avg_cost1 = fluid.layers.mean(x=cost1)</span><br><span class="line">        avg_cost2 = fluid.layers.mean(x=cost2)</span><br><span class="line">        <span class="comment"># 最后加权求和</span></span><br><span class="line">        avg_cost = avg_cost0 + <span class="number">0.3</span> * avg_cost1 + <span class="number">0.3</span> * avg_cost2</span><br><span class="line">        <span class="comment"># 预测精度看第一个输出即可</span></span><br><span class="line">        accuracy = fluid.layers.accuracy(input=out, label=label)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 对于其他模型</span></span><br><span class="line">        <span class="comment"># 在训练中采用多类交叉熵作为损失函数</span></span><br><span class="line">        cost = fluid.layers.cross_entropy(input=predict, label=label)</span><br><span class="line">        <span class="comment"># 得到的平均损失用于在上一层中的训练主函数中计算梯度</span></span><br><span class="line">        avg_cost = fluid.layers.mean(cost)</span><br><span class="line">        <span class="comment"># 计算当前预测精度</span></span><br><span class="line">        accuracy = fluid.layers.accuracy(input=predict, label=label)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回平均损失和预测精度</span></span><br><span class="line">    <span class="keyword">return</span> [avg_cost, accuracy]</span><br></pre></td></tr></table></figure>
<p>训练程序是在训练过程中通过模型返回的predict结果来计算损失率和预测精度的函数。这里特别处理了GoogleNet的三个损失率分量的加权求和计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 优化器程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer_program</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 输入学习率，也就是训练的速度，这里与网络的训练收敛速度有关</span></span><br><span class="line">    <span class="keyword">return</span> fluid.optimizer.Adam(learning_rate=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure>
<p>优化器程序是在训练过程中通过设置学习率、也就是训练的速度后返回一个特定的Adam优化器实例的函数，这是python类的用法。Adam优化器是优化器的一种，对梯度的一阶矩估计和二阶矩估计进行综合考虑，计算出当前神经网络中各个神经元的参数更新的步长，以加快梯度下降速度。Adam优化器在当前深度学习优化器中被默认是相当优异的</p>
<h5 id="训练主函数"><a href="#训练主函数" class="headerlink" title="训练主函数"></a>训练主函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(use_cuda, model, params_dirname=None)</span>:</span></span><br><span class="line">    <span class="comment"># 事实上本次训练使用的是CPU，所以use_cuda应当固定为False</span></span><br><span class="line">    place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">    <span class="comment"># 每次训练所选取的样本数量，适当的batch_size可以使得数据并行化处理且梯度下降的方向更加明确</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'inception_v4'</span>:</span><br><span class="line">        <span class="comment"># 针对inception_v4调整batch_size</span></span><br><span class="line">        BATCH_SIZE = <span class="number">256</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        BATCH_SIZE = <span class="number">128</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练集数据输入，这里使用了shuffle，是用来将读入的数据进行打乱操作的</span></span><br><span class="line">    <span class="comment"># 所以需要定义一个打乱缓冲区的大小buf_size</span></span><br><span class="line">    train_reader = paddle.batch(</span><br><span class="line">        paddle.reader.shuffle(</span><br><span class="line">            paddle.dataset.cifar.train10(), buf_size=<span class="number">128</span>*<span class="number">100</span>), </span><br><span class="line">        batch_size=BATCH_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试集数据输入</span></span><br><span class="line">    test_reader = paddle.batch(</span><br><span class="line">        paddle.dataset.cifar.test10(), batch_size=BATCH_SIZE)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"\nstart training"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输入数据的先后顺序格式</span></span><br><span class="line">    feed_order = [<span class="string">'pixel'</span>, <span class="string">'label'</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成默认的训练主程序和启动程序</span></span><br><span class="line">    main_program = fluid.default_main_program()</span><br><span class="line">    star_program = fluid.default_startup_program()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出预测结果，这里没有传入数据是因为数据传入操作是之后的训练过程中设置的</span></span><br><span class="line">    predict = inference_network(model)</span><br><span class="line">    <span class="comment"># 获取训练结果</span></span><br><span class="line">    avg_cost, acc = train_network(predict, model)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 此处开始是测试程序</span></span><br><span class="line">    test_program = main_program.clone(for_test=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 优化器</span></span><br><span class="line">    optimizer = optimizer_program()</span><br><span class="line">    <span class="comment"># 告诉优化器在当前平均损失的基础上计算梯度以减少损失</span></span><br><span class="line">    optimizer.minimize(avg_cost)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行器，将以上操作放入CPU执行</span></span><br><span class="line">    exe = fluid.Executor(place)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># epoch意思为所有数据项目完成一次前向运算和反向传播的次数</span></span><br><span class="line">    <span class="comment"># 这里因为我们训练时间有限，还是1~3次就够了</span></span><br><span class="line">    EPOCH_NUM = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计图横纵坐标的列表</span></span><br><span class="line">    train_steps=[]</span><br><span class="line">    train_costs=[]</span><br><span class="line">    test_steps=[]</span><br><span class="line">    test_costs=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对训练结果进行损失率检测的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_test</span><span class="params">(program, reader)</span>:</span></span><br><span class="line">        <span class="comment"># 检测次数count</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 输入数据的变量名列表，这里应该就是feed_order中的‘pixel’和‘label’</span></span><br><span class="line">        <span class="comment"># global_block经查应该是fluid的全局作用域</span></span><br><span class="line">        feed_var_list = [</span><br><span class="line">            program.global_block().var(var_name) <span class="keyword">for</span> var_name <span class="keyword">in</span> feed_order</span><br><span class="line">        ]</span><br><span class="line">        <span class="comment"># 数据喂入器DataFeeder负责将数据读取器的输入转换成一种特殊的数据结构中去</span></span><br><span class="line">        <span class="comment"># 从而能够将该数据结构的数据输入到执行器中</span></span><br><span class="line">        feeder_test = fluid.DataFeeder(feed_list=feed_var_list, place=place)</span><br><span class="line">        test_exe = fluid.Executor(place);</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这个变量是记录包括数据变量名在内的所有数据个数以及对应的损失率的</span></span><br><span class="line">        accumulated = len([avg_cost, acc]) * [<span class="number">0</span>];</span><br><span class="line">        <span class="comment"># 将数据读取器reader中获取到的输入数据通过enumerate转换为索引序列</span></span><br><span class="line">        <span class="keyword">for</span> tid, test_data <span class="keyword">in</span> enumerate(reader()):</span><br><span class="line">            <span class="comment"># 执行训练结果损失率检测的执行器test_exe，喂入测试集数据test_data，得到当前的平均损失率avg_cost_np</span></span><br><span class="line">            avg_cost_np = test_exe.run(</span><br><span class="line">                program=program,</span><br><span class="line">                feed=feeder_test.feed(test_data),</span><br><span class="line">                fetch_list=[avg_cost, acc])</span><br><span class="line">            <span class="comment"># 记录当前的数据个数，这里使用的zip函数将accumulate和avg_cost_np打包成了一个元组进行记录</span></span><br><span class="line">            <span class="comment"># 其中x[1][0]应该是avg_cost_np中的第一项，也就是损失率loss</span></span><br><span class="line">            accumulated = [x[<span class="number">0</span>] + x[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> zip(accumulated, avg_cost_np)]</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 返回的是accumulated中每一条记录中的x与count相除的结果，为平均每次检测得到的损失率</span></span><br><span class="line">        <span class="keyword">return</span> [x/count <span class="keyword">for</span> x <span class="keyword">in</span> accumulated]</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 训练循环函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_loop</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 同样是输入数据的变量名列表，应该就是feed_order中的‘pixel’和‘label’</span></span><br><span class="line">        feed_var_list_loop = [</span><br><span class="line">            main_program.global_block().var(var_name) <span class="keyword">for</span> var_name <span class="keyword">in</span> feed_order</span><br><span class="line">        ]</span><br><span class="line">        feeder = fluid.DataFeeder(feed_list=feed_var_list_loop, place=place)</span><br><span class="line">        <span class="comment"># 开始运行启动程序</span></span><br><span class="line">        exe.run(star_program)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记录训练次数</span></span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练次数id为pass_id，range生成了一个以epoch次数的</span></span><br><span class="line">        <span class="keyword">for</span> pass_id <span class="keyword">in</span> range(EPOCH_NUM):</span><br><span class="line">            <span class="comment"># 每次训练中的分组训练次数step_id，</span></span><br><span class="line">            <span class="keyword">for</span> step_id, train_data <span class="keyword">in</span> enumerate(train_reader()):</span><br><span class="line">                <span class="comment"># 执行训练执行器，喂入训练集数据train_data，得到当前的平均损失率avg_lost_value</span></span><br><span class="line">                avg_loss_value = exe.run(</span><br><span class="line">                    main_program,</span><br><span class="line">                    feed=feeder.feed(train_data),</span><br><span class="line">                    fetch_list=[avg_cost, acc])</span><br><span class="line">                <span class="comment"># 每50次输出一次训练结果，分别是训练次数，分组训练次数，损失率，预测精度</span></span><br><span class="line">                <span class="keyword">if</span> step_id % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">"\nPass %d, Batch %d, Cost %f, Acc %f"</span> % (</span><br><span class="line">                        step_id, pass_id, avg_loss_value[<span class="number">0</span>], avg_loss_value[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则单纯输出点表示正在训练</span></span><br><span class="line">                    sys.stdout.write(<span class="string">'.'</span>)</span><br><span class="line">                    sys.stdout.flush()</span><br><span class="line">                    <span class="comment"># 并更新一次训练损失率统计图</span></span><br><span class="line">                    train_steps.append(step)</span><br><span class="line">                    train_costs.append(avg_loss_value[<span class="number">0</span>])</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 每次训练的全部分组训练结束后，进行一次损失率检测，</span></span><br><span class="line">            avg_cost_test, accuracy_test = train_test(test_program, reader=test_reader)</span><br><span class="line">            <span class="comment"># 输出损失率检测结果</span></span><br><span class="line">            print(<span class="string">'\nTest with Pass &#123;0&#125;, Loss &#123;1:2.2&#125;, Acc &#123;2:2.2&#125;'</span>.format(</span><br><span class="line">                pass_id, avg_cost_test, accuracy_test))</span><br><span class="line">            <span class="comment"># 并更新一次检测损失率统计图</span></span><br><span class="line">            test_steps.append(step)</span><br><span class="line">            test_costs.append(avg_cost_test)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 若模型保存地址为有效，则自动保存本次训练的模型结果</span></span><br><span class="line">            <span class="comment"># 其中从第二个开始的变量意思为：</span></span><br><span class="line">            <span class="comment"># 喂入数据的基本格式（pixel）</span></span><br><span class="line">            <span class="comment"># 保存预测结果所使用的变量组（predict）</span></span><br><span class="line">            <span class="comment"># 执行预测程序（exe=fluid.Executor(place)）</span></span><br><span class="line">            <span class="keyword">if</span> params_dirname <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> model == <span class="string">'googlenet'</span>:</span><br><span class="line">                    model_out, _, _ = predict</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    model_out = predict</span><br><span class="line">                fluid.io.save_inference_model(params_dirname, [<span class="string">"pixel"</span>], [model_out], exe)</span><br><span class="line">                </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在以上函数和变量定义全部结束后，即可开始训练</span></span><br><span class="line">    train_loop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练结束后绘制损失率统计图</span></span><br><span class="line">    %matplotlib inline</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    </span><br><span class="line">    train_title = <span class="string">"Train cost"</span></span><br><span class="line">    test_title = <span class="string">"Test cost"</span></span><br><span class="line">    title = <span class="string">"Train cost/Test cost"</span></span><br><span class="line">    <span class="comment"># 标题，横纵坐标</span></span><br><span class="line">    plt.title(title, fontsize=<span class="number">24</span>) </span><br><span class="line">    plt.xlabel(<span class="string">"step"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"cost"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">    <span class="comment"># 设置图例</span></span><br><span class="line">    plt.plot(train_steps, train_costs, color=<span class="string">'blue'</span>, label=train_title)</span><br><span class="line">    plt.plot(test_steps, test_costs, color=<span class="string">'red'</span>, label=test_title)</span><br><span class="line">    plt.legend()</span><br><span class="line">    <span class="comment"># 显示统计图</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>训练主函数train相对较长，而且还内部声明了对训练结果进行损失率检测的train_test、训练循环函数train_loop几个函数，这里绘制了程序流程图以方便理解，如下图所示：</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/train-func.png" alt="训练主函数"></p>
<p>从代码和流程图中，我们可以看出训练主函数的主要工作是：</p>
<ul>
<li>对训练进行一系列的函数调用关系的绑定、变量的声明和初始化以及训练所需的主要元器件实例（执行器、启动函数、主函数、优化器、数据集）的生成</li>
<li>进行实际训练过程中的执行、模型生成、数据生成</li>
<li>训练结束后图表的绘制</li>
</ul>
<p>在这里需要说明的有以下几点：</p>
<ul>
<li><p>在paddlepaddle中损失率为均方差函数得出的，故没有固定单位，但是一般在训练过程中是呈现总体下降的趋势，损失率越低，模型的效果越好。</p>
</li>
<li><p>准确度较容易理解，就是当前模型能够准确识别的样本个数占当前训练样本或测试样本的百分比。</p>
</li>
<li><p>batch_size是指每次训练时输入的样本个数，合理的batch_size设置能够减缓在训练过程中的损失率上下震荡的趋势，使得模型的损失率下降速度更快，精确率提升更加明显。根据经验，过大的batch_size可能会导致损失率下降或精确度提升到某一点后停滞，并且导致每次训练的时间和性能开销增大，过小的batch_size则会导致损失率上下震荡，下降速度减慢。</p>
</li>
<li><p>epoch是指所有样本完成一次前向运算和反向传播的次数，也就是所有样本都参与过训练的次数。epoch决定了整个训练的总时长，如果使用的是GPU，则可以因为并行处理性能高、训练速度较快而将epoch定在30~50甚至更多，而使用CPU则建议1~5，否则将导致训练时间过长，无法及时生成模型文件。</p>
</li>
</ul>
<h5 id="预测主函数"><a href="#预测主函数" class="headerlink" title="预测主函数"></a>预测主函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测主程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infer</span><span class="params">(use_cuda, params_dirname=None)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">    <span class="comment"># 事实上本次训练使用的是CPU，所以use_cuda应当固定为False</span></span><br><span class="line">    place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">    <span class="comment"># 创建执行器</span></span><br><span class="line">    exe = fluid.Executor(place)</span><br><span class="line">    <span class="comment"># 创建用于预测的局部作用域</span></span><br><span class="line">    inference_scope = fluid.core.Scope()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用于装载需要预测的图片的子函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(infer_file)</span>:</span></span><br><span class="line">        <span class="comment"># 打开图片</span></span><br><span class="line">        im = Image.open(infer_file)</span><br><span class="line">        </span><br><span class="line">        %matplotlib inline</span><br><span class="line">        <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">        <span class="comment"># 清空plt输出</span></span><br><span class="line">        plt.close()</span><br><span class="line">        <span class="comment"># 输出当前图片</span></span><br><span class="line">        plt.imshow(im)</span><br><span class="line">        plt.show()</span><br><span class="line">        <span class="comment"># 将图片拉伸为32 * 32，与训练图片相同的大小</span></span><br><span class="line">        im = im.resize((<span class="number">32</span>, <span class="number">32</span>), Image.ANTIALIAS)</span><br><span class="line">        <span class="comment"># 将图片转换为像素数组</span></span><br><span class="line">        im = numpy.array(im).astype(numpy.float32)</span><br><span class="line">        <span class="comment"># 注意，一般存储图片的像素数组格式为W（宽度）、H（高度）、C（像素通道）</span></span><br><span class="line">        <span class="comment"># 但是paddlepaddle需要将格式转换为CHW格式，所以使用了transpose函数</span></span><br><span class="line">        im = im.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 过滤值为255以上的颜色，也就是进行灰度变换</span></span><br><span class="line">        im = im/<span class="number">255.0</span></span><br><span class="line">        <span class="comment"># 向图片添加一个维度用来模拟为列表结构，事实上该维度只有这张图片一个元素</span></span><br><span class="line">        im = numpy.expand_dims(im, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 返回处理好的图片</span></span><br><span class="line">        <span class="keyword">return</span> im</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取程序所在的当前位置</span></span><br><span class="line">    cur_dir = os.path.dirname(os.path.realpath(<span class="string">'__file__'</span>))</span><br><span class="line">    <span class="comment"># 设置预测图片</span></span><br><span class="line">    img = load_image(cur_dir + <span class="string">'/image/dog.png'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进入当前的局部作用域</span></span><br><span class="line">    <span class="keyword">with</span> fluid.scope_guard(inference_scope):</span><br><span class="line">        <span class="comment"># 使用fluid.io.load_inference_model去获取以下的信息</span></span><br><span class="line">        <span class="comment"># inference_program：当前的预测程序</span></span><br><span class="line">        <span class="comment"># feed_target_names：喂入数据需要的变量名称</span></span><br><span class="line">        <span class="comment"># fetch_targets：获取数据的目标，通过使用这个目标从而在exe.run中输入fetch_list</span></span><br><span class="line">        [inference_program, feed_target_names, fetch_targets] = fluid.io.load_inference_model(params_dirname, exe)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输入到神经网络的维度数目一般为4D或5D，使用trainpiler这种编译方式可以将输入的数据结构进行转译</span></span><br><span class="line">        <span class="comment"># 转译的目的主要是能够将fluid生成的对应自有fluid解释器、</span></span><br><span class="line">        <span class="comment"># 而非Python解释器（这样速度更快）的protobuf message表示的程序翻译成 C++ 或其他语言的程序</span></span><br><span class="line">        inference_transpiler_program = inference_program.clone()</span><br><span class="line">        t = fluid.transpiler.InferenceTranspiler()</span><br><span class="line">        t.transpile(inference_transpiler_program, place)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将喂入得数据构造成如下结构&#123;feed_target_name: feed_target_data&#125;</span></span><br><span class="line">        <span class="comment"># 预测的结构带有与fetch_targets对应的一系列数据</span></span><br><span class="line">        <span class="comment"># 这里分别使用带有trainpiler转译和不带有转译的程序进行预测</span></span><br><span class="line">        results = exe.run(inference_program,</span><br><span class="line">            feed=&#123;feed_target_names[<span class="number">0</span>]: img&#125;,</span><br><span class="line">            fetch_list=fetch_targets)</span><br><span class="line">            </span><br><span class="line">        transpiler_results = exe.run(inference_transpiler_program,</span><br><span class="line">            feed=&#123;feed_target_names[<span class="number">0</span>]: img&#125;,</span><br><span class="line">            fetch_list=fetch_targets)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 断言，确定以上两次预测的结果(就1个，所以是[0])的长度是否相同</span></span><br><span class="line">        <span class="comment"># 若相同则继续比对结果中的各个项目是否相同</span></span><br><span class="line">        <span class="comment"># 总之，就是在比对转译前后结果是否能够相同</span></span><br><span class="line">        <span class="keyword">assert</span> len(results[<span class="number">0</span>]) == len(transpiler_results[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(results[<span class="number">0</span>])):</span><br><span class="line">            numpy.testing.assert_almost_equal(</span><br><span class="line">                results[<span class="number">0</span>][i], transpiler_results[<span class="number">0</span>][i], decimal=<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">         <span class="comment"># 预测标签，这个顺序一般是和训练的模型数据的顺序相同的</span></span><br><span class="line">        label_list = [</span><br><span class="line">            <span class="string">"airplane"</span>, <span class="string">"automobile"</span>, <span class="string">"bird"</span>, <span class="string">"cat"</span>, <span class="string">"deer"</span>, <span class="string">"dog"</span>, <span class="string">"frog"</span>,</span><br><span class="line">            <span class="string">"horse"</span>, <span class="string">"ship"</span>, <span class="string">"truck"</span></span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 输出预测结果</span></span><br><span class="line">        print(<span class="string">"infer results: %s"</span> % label_list[numpy.argmax(results[<span class="number">0</span>])])</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/predict-func.png" alt="预测主函数"></p>
<center>图2.7 预测主函数predict的程序流程图</center>

<h5 id="程序主函数"><a href="#程序主函数" class="headerlink" title="程序主函数"></a>程序主函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(use_cuda)</span>:</span></span><br><span class="line">    <span class="comment"># 如果需要使用GPU的CUDA函数库，则需要判断fluid是否根据cuda进行了编译</span></span><br><span class="line">    <span class="keyword">if</span> use_cuda <span class="keyword">and</span> <span class="keyword">not</span> fluid.core.is_compiled_with_cuda():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意：更改训练模型请更改此处的model变量</span></span><br><span class="line">    model=<span class="string">'googlenet'</span></span><br><span class="line">    <span class="comment"># 模型文件保存路径</span></span><br><span class="line">    save_path = <span class="string">'image_classification_'</span>+model+<span class="string">'.inference.model'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    train(use_cuda=use_cuda, model=model, params_dirname=save_path)</span><br><span class="line">    <span class="comment"># 注意：如果报出optimzer相关的错误，可以尝试在kernel操作中“重启”，之后再从头开始重新运行</span></span><br><span class="line">    <span class="comment"># 这一错误可能是在对部分函数中途修改并重新运行后optimizer不再识别其输入导致的问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预测，如果训练已经得出了save_path指定的模型文件</span></span><br><span class="line">    <span class="comment"># 预测程序则可以独立运行，否则不可以运行</span></span><br><span class="line">    infer(use_cuda=use_cuda, params_dirname=save_path)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 根据当前测试环境，使用CPU</span></span><br><span class="line">    main(use_cuda=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>程序主函数main的主要功能是先确定环境变量：使用CPU/GPU、当前使用的模型名称、模型文件保存路径等，再执行训练主函数和预测主函数，是整个程序的最顶层模块。</p>
<h4 id="编写神经网络模型代码"><a href="#编写神经网络模型代码" class="headerlink" title="编写神经网络模型代码"></a>编写神经网络模型代码</h4><p>注：由于在“实验原理”章节中，对于各神经网络模型的关键技术原理和关键模块结构已经进行了说明，此处代码部分对于这些内容不再重复解释。</p>
<p>在整体上，神经网络模型的实现主要是基于paddlepaddle提供的卷积层、池化层、全连接层等函数API以及层与层之间的连接来实现的，各神经网络的共性的地方在于以下2点：</p>
<ul>
<li>经过若干个卷积、池化层结构之后，在最后输出结果之前的一层全连接层中都要经历一次softmax归一化，通过softmax归一化得到每个类别的概率，softmax能够将输入映射为0-1之间的实数，作为取到某个分类的概率，作为最终的输出结果。</li>
<li>在每一组神经网络之间，常用dropout层对结果按照一定概率随机丢弃一些特征，以防止过拟合；同时也常用batchnorm，将每次输入的数据分布进行规范化，让其均匀分布在当前层上，从而加速神经网络的训练速度、同样防止过拟合。</li>
</ul>
<h5 id="VGG模型"><a href="#VGG模型" class="headerlink" title="VGG模型"></a>VGG模型</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgg模型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码来自：http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_bn_drop</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="comment"># 创建神经网络的公用函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(ipt, num_filter, groups, dropouts)</span>:</span></span><br><span class="line">        <span class="comment"># 返回根据传入参数创建的神经网络</span></span><br><span class="line">        <span class="keyword">return</span> fluid.nets.img_conv_group(</span><br><span class="line">            <span class="comment"># 图像输入</span></span><br><span class="line">            input=ipt,</span><br><span class="line">            <span class="comment"># 池化窗口大小为2*2</span></span><br><span class="line">            pool_size=<span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 池化窗口移动的步长</span></span><br><span class="line">            pool_stride=<span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 该神经网络层组的过滤器数量，可以认为是神经元个数</span></span><br><span class="line">            conv_num_filter=[num_filter] * groups,</span><br><span class="line">            <span class="comment"># 过滤器大小，默认值为3</span></span><br><span class="line">            conv_filter_size=<span class="number">3</span>,</span><br><span class="line">            <span class="comment"># 激活函数的类型，这里选用RELU</span></span><br><span class="line">            conv_act=<span class="string">'relu'</span>,</span><br><span class="line">            <span class="comment"># 在每一层后使用batchnorm以加速神经网络训练速度</span></span><br><span class="line">            <span class="comment"># batchnorm能够将每次输入的数据分布进行规范化</span></span><br><span class="line">            conv_with_batchnorm=<span class="literal">True</span>,</span><br><span class="line">            <span class="comment"># 对于每一层进行batchnorm后的dropout概率</span></span><br><span class="line">            <span class="comment"># dropout是避免过拟合的手段，按照一定概率随机丢弃一些特征</span></span><br><span class="line">            conv_batchnorm_drop_rate=dropouts,</span><br><span class="line">            <span class="comment"># 池化类型为最大池化，提取每个池化窗口中的最显著特征</span></span><br><span class="line">            pool_type=<span class="string">'max'</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 以下各函数中最后一个列表为每一层结束后dropout的概率</span></span><br><span class="line">    <span class="comment"># 一般在两组卷积层之间不使用dropout</span></span><br><span class="line">    <span class="comment"># 第1组卷积层，2次连续卷积，卷积核数目64</span></span><br><span class="line">    conv1 = conv_block(input, <span class="number">64</span>, <span class="number">2</span>, [<span class="number">0.3</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 第2组卷积层，2次连续卷积，卷积核数目128</span></span><br><span class="line">    conv2 = conv_block(conv1, <span class="number">128</span>, <span class="number">2</span>, [<span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 第3组卷积层，3次连续卷积，卷积核数目为256</span></span><br><span class="line">    conv3 = conv_block(conv2, <span class="number">256</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 第4组卷积层，3次连续卷积，卷积核数目为512</span></span><br><span class="line">    conv4 = conv_block(conv3, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 第5组卷积层，3次连续卷积，卷积核数目为512</span></span><br><span class="line">    conv5 = conv_block(conv4, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后一层结束后添加一层概率为0.5的dropout层</span></span><br><span class="line">    drop = fluid.layers.dropout(x=conv5, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># 添加全连接层，维度数为512</span></span><br><span class="line">    fc1 = fluid.layers.fc(input=drop, size=<span class="number">512</span>, act=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 在全连接层结束后添加batchnorm防止过拟合</span></span><br><span class="line">    bn = fluid.layers.batch_norm(input=fc1, act=<span class="string">'relu'</span>)</span><br><span class="line">    <span class="comment"># 添加概率为0.5的dropout层</span></span><br><span class="line">    drop2 = fluid.layers.dropout(x=bn, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># 添加全连接层，维度数为512</span></span><br><span class="line">    fc2 = fluid.layers.fc(input=drop2, size=<span class="number">512</span>, act=<span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最后，添加预测用的全连接层，映射到类别维度大小的向量，本次数据类别一共10种</span></span><br><span class="line">    <span class="comment"># 通过softmax归一化得到每个类别的概率，softmax是将输入映射为0-1之间的实数，作为取到某个分类的概率</span></span><br><span class="line">    <span class="comment"># 可以认为是一个分类器</span></span><br><span class="line">    predict = fluid.layers.fc(input=fc2, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出最终的结果</span></span><br><span class="line">    <span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure>
<h5 id="ResNet模型"><a href="#ResNet模型" class="headerlink" title="ResNet模型"></a>ResNet模型</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resnet模型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码来自：http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为resnet_cifar10需要用到的工具函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conv_bn_layer为自带batchnorm的神经网络层</span></span><br><span class="line"><span class="comment"># input为输入，ch_out为滤波器个数，该个数与输出图像通道相同，故赋值为channel_out=ch_out</span></span><br><span class="line"><span class="comment"># filter_size为过滤器大小，stride为窗口移动的步长</span></span><br><span class="line"><span class="comment"># padding为填充格式，VALID对于多出来的数据直接丢弃，SAME将多出来的数据继续填充到下一层的额外行和列</span></span><br><span class="line"><span class="comment"># act为激活函数，这里使用RELU函数</span></span><br><span class="line"><span class="comment"># bias_attr为False，说明不需要得到单个卷积核卷积图片的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_bn_layer</span><span class="params">(input,</span></span></span><br><span class="line"><span class="function"><span class="params">                  ch_out,</span></span></span><br><span class="line"><span class="function"><span class="params">                  filter_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  stride,</span></span></span><br><span class="line"><span class="function"><span class="params">                  padding,</span></span></span><br><span class="line"><span class="function"><span class="params">                  act=<span class="string">'relu'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  bias_attr=False)</span>:</span></span><br><span class="line">    tmp = fluid.layers.conv2d(</span><br><span class="line">        input=input,</span><br><span class="line">        filter_size=filter_size,</span><br><span class="line">        num_filters=ch_out,</span><br><span class="line">        stride=stride,</span><br><span class="line">        padding=padding,</span><br><span class="line">        act=<span class="literal">None</span>,</span><br><span class="line">        bias_attr=bias_attr)</span><br><span class="line">    <span class="keyword">return</span> fluid.layers.batch_norm(input=tmp, act=act)</span><br><span class="line"></span><br><span class="line"><span class="comment"># shortcut为残差模块的“直连路径”</span></span><br><span class="line"><span class="comment"># 在resnet中引入残差模块后，解决了网络层数加深导致准确度下降的问题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortcut</span><span class="params">(input, ch_in, ch_out, stride)</span>:</span></span><br><span class="line">    <span class="comment"># 残差模块输入和输出特征通道数不等时，采用1x1卷积的升维操作</span></span><br><span class="line">    <span class="keyword">if</span> ch_in != ch_out:</span><br><span class="line">        <span class="keyword">return</span> conv_bn_layer(input, ch_out, <span class="number">1</span>, stride, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 残差模块输入和输出通道相等时，采用直连操作</span></span><br><span class="line">        <span class="keyword">return</span> input</span><br><span class="line"></span><br><span class="line"><span class="comment"># basicblock为基础残差模块，由两组3x3卷积组成的路径和一条"直连"路径组成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basicblock</span><span class="params">(input, ch_in, ch_out, stride)</span>:</span></span><br><span class="line">    <span class="comment"># 由两组3x3卷积组成的路径</span></span><br><span class="line">    tmp = conv_bn_layer(input, ch_out, <span class="number">3</span>, stride, <span class="number">1</span>)</span><br><span class="line">    tmp = conv_bn_layer(tmp, ch_out, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, act=<span class="literal">None</span>, bias_attr=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 一条“直连”路径</span></span><br><span class="line">    short = shortcut(input, ch_in, ch_out, stride)</span><br><span class="line">    <span class="comment"># 使用fluid自动在每一层后添加这一残差模块的输入</span></span><br><span class="line">    <span class="keyword">return</span> fluid.layers.elementwise_add(x=tmp, y=short, act=<span class="string">'relu'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># layer_warp为一组残差模块，由若干个残差模块堆积而成</span></span><br><span class="line"><span class="comment"># 这里的block_func事实上指的就是basicblock</span></span><br><span class="line"><span class="comment"># ch_in和ch_out分别为输入输出通道</span></span><br><span class="line"><span class="comment"># count为残差模块的个数，stride为窗口移动步长</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layer_warp</span><span class="params">(block_func, input, ch_in, ch_out, count, stride)</span>:</span></span><br><span class="line">    tmp = block_func(input, ch_in, ch_out, stride)</span><br><span class="line">    <span class="comment"># 每组中第一个残差模块滑动窗口大小与其他可以不同，以用来减少特征图在垂直和水平方向的大小</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, count):</span><br><span class="line">        tmp = block_func(tmp, ch_out, ch_out, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># resnet_cifar10模型主函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet_cifar10</span><span class="params">(ipt, depth=<span class="number">32</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 除第一层卷积层和最后一层全连接层之外</span></span><br><span class="line">    <span class="comment"># 要求三组 layer_warp 总的含参层数能够被6整除</span></span><br><span class="line">    <span class="comment"># 即 resnet_cifar10 的 depth 要满足 (depth−2) </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 因此深度的可能取值： 20, 32, 44, 56, 110, 1202</span></span><br><span class="line">    <span class="keyword">assert</span> (depth - <span class="number">2</span>) % <span class="number">6</span> == <span class="number">0</span></span><br><span class="line">    n = (depth - <span class="number">2</span>) // <span class="number">6</span></span><br><span class="line">    nStages = &#123;<span class="number">16</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 底层输入连接一层带batchnorm的卷积层</span></span><br><span class="line">    conv1 = conv_bn_layer(ipt, ch_out=<span class="number">16</span>, filter_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 连接3组残差模块</span></span><br><span class="line">    res1 = layer_warp(basicblock, conv1, <span class="number">16</span>, <span class="number">16</span>, n, <span class="number">1</span>)</span><br><span class="line">    res2 = layer_warp(basicblock, res1, <span class="number">16</span>, <span class="number">32</span>, n, <span class="number">2</span>)</span><br><span class="line">    res3 = layer_warp(basicblock, res2, <span class="number">32</span>, <span class="number">64</span>, n, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 对网络做均值池化，可以看到pool_type=‘avg’表示均值池化</span></span><br><span class="line">    pool = fluid.layers.pool2d(</span><br><span class="line">        input=res3, pool_size=<span class="number">8</span>, pool_type=<span class="string">'avg'</span>, pool_stride=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 添加全连接层作为预测层，通过softmax归一化得到每个类别的概率</span></span><br><span class="line">    predict = fluid.layers.fc(input=pool, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure>
<h5 id="GoogleNet模型"><a href="#GoogleNet模型" class="headerlink" title="GoogleNet模型"></a>GoogleNet模型</h5><p>我们获得的初始GoogleNet模型代码使用的是早期的paddlepaddle版本，因此我们花费了一些时间查阅了paddlepaddle官网的API文档，研究了不同版本之间的API对应关系和调用方式上的差异。最终，我们成功地将该模型代码移植到了AI Studio在线项目平台上的paddlepaddle V1.4版本上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># googlenet模型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码来自：https://www.cnblogs.com/charlotte77/p/8066867.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为googlenet需要用到的工具函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inception为一个inceoption网络，目前已经发展到了inceptionV4和inception-resnet</span></span><br><span class="line"><span class="comment"># inception主要的特点是在同一层级上运行多个不同尺寸的卷积层，这一特性解决了多个问题</span></span><br><span class="line"><span class="comment"># 1. 消除了信息分布的均匀程度对卷积核大小的选取影响</span></span><br><span class="line"><span class="comment"># 2. 减缓了网络层数过深导致的梯度损失以及过拟合</span></span><br><span class="line"><span class="comment"># 3. 缓解了简单堆叠多层网络导致的计算资源的消耗</span></span><br><span class="line"><span class="comment"># 但是这个特点同样带来了缺陷：</span></span><br><span class="line"><span class="comment"># 池化层不会改变特征通道数，拼接后会导致特征的通道数较大，经过几层这样的模块堆积后，通道数会越来越大，导致参数和计算量也随之增大</span></span><br><span class="line"><span class="comment"># 因此，inception还通过引入3个1*1卷积层进行降维，减少通道数</span></span><br><span class="line"><span class="comment"># 下面的版本是inceptionv1版本，v2引入batchnorm，v3对卷积层进一步分解，v4引入了res-net</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些参数的意思为：</span></span><br><span class="line"><span class="comment"># name：整个inception的名称</span></span><br><span class="line"><span class="comment"># channels：通道个数</span></span><br><span class="line"><span class="comment"># filter1、filter3R、filter3、filter5R、filter5、proj：各个卷积层的过滤器数量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inception</span><span class="params">(name, input, channels, filter1, filter3R, filter3, filter5R,</span></span></span><br><span class="line"><span class="function"><span class="params">              filter5, proj)</span>:</span></span><br><span class="line">    <span class="comment"># 1*1卷积层_1</span></span><br><span class="line">    cov1 = fluid.layers.conv2d(</span><br><span class="line">        input=input,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=filter1,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1*1卷积层_3r</span></span><br><span class="line">    cov3r = fluid.layers.conv2d(</span><br><span class="line">        input=input,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=filter3R,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 1*1卷积层_3r的下一层3*3卷积层</span></span><br><span class="line">    cov3 = fluid.layers.conv2d(</span><br><span class="line">        input=cov3r,</span><br><span class="line">        filter_size=<span class="number">3</span>,</span><br><span class="line">        num_filters=filter3,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1*1卷积层_5r</span></span><br><span class="line">    cov5r = fluid.layers.conv2d(</span><br><span class="line">        input=input,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=filter5R,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 1*1卷积层_5r的下一层5*5卷积层</span></span><br><span class="line">    cov5 = fluid.layers.conv2d(</span><br><span class="line">        input=cov5r,</span><br><span class="line">        filter_size=<span class="number">5</span>,</span><br><span class="line">        num_filters=filter5,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3*3最大池化层</span></span><br><span class="line">    pool1 = fluid.layers.pool2d(</span><br><span class="line">        input=input,</span><br><span class="line">        pool_size=<span class="number">3</span>,</span><br><span class="line">        pool_type=<span class="string">"max"</span>,</span><br><span class="line">        pool_stride=<span class="number">1</span>,</span><br><span class="line">        pool_padding=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3*3最大池化层的下一层1*1卷积层</span></span><br><span class="line">    covprj = fluid.layers.conv2d(</span><br><span class="line">        input=pool1,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=proj,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全连接层将以上的结果汇总处理</span></span><br><span class="line">    cat = fluid.layers.concat(input=[cov1, cov3, cov5, covprj], axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> cat</span><br><span class="line"></span><br><span class="line"><span class="comment"># googlenet模型主函数</span></span><br><span class="line"><span class="comment"># class_dim为当前类别的维度个数，这里一共有10个类，因此填10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">googlenet</span><span class="params">(input, class_dim)</span>:</span></span><br><span class="line">    <span class="comment"># stage 1 </span></span><br><span class="line">    <span class="comment"># 7*7卷积层</span></span><br><span class="line">    conv1 = fluid.layers.conv2d(</span><br><span class="line">        input=input,</span><br><span class="line">        filter_size=<span class="number">7</span>,</span><br><span class="line">        num_filters=<span class="number">64</span>,</span><br><span class="line">        stride=<span class="number">2</span>,</span><br><span class="line">        padding=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 3*3最大池化层</span></span><br><span class="line">    pool1 = fluid.layers.pool2d(</span><br><span class="line">        input=conv1, pool_size=<span class="number">3</span>, pool_type=<span class="string">"max"</span>, pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stage 2</span></span><br><span class="line">    <span class="comment"># 1*1卷积层</span></span><br><span class="line">    conv2_1 = fluid.layers.conv2d(</span><br><span class="line">        input=pool1,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=<span class="number">64</span>,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 3*3卷积层</span></span><br><span class="line">    conv2_2 = fluid.layers.conv2d(</span><br><span class="line">        input=conv2_1,</span><br><span class="line">        filter_size=<span class="number">3</span>,</span><br><span class="line">        num_filters=<span class="number">192</span>,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3*3最大池化层</span></span><br><span class="line">    pool2 = fluid.layers.pool2d(</span><br><span class="line">        input=conv2_2, pool_size=<span class="number">3</span>, pool_type=<span class="string">'max'</span>, pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stage 3</span></span><br><span class="line">    <span class="comment"># 2组inception+1个3*3最大池化层</span></span><br><span class="line">    ince3a = inception(<span class="string">"ince3a"</span>, pool2, <span class="number">192</span>, <span class="number">64</span>, <span class="number">96</span>, <span class="number">128</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">    ince3b = inception(<span class="string">"ince3b"</span>, ince3a, <span class="number">256</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">192</span>, <span class="number">32</span>, <span class="number">96</span>, <span class="number">64</span>)</span><br><span class="line">    pool3 = fluid.layers.pool2d(</span><br><span class="line">        input=ince3b, pool_size=<span class="number">3</span>, pool_type=<span class="string">'max'</span>, pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stage 4</span></span><br><span class="line">    <span class="comment"># 5组inception+1个3*3最大池化层</span></span><br><span class="line">    ince4a = inception(<span class="string">"ince4a"</span>, pool3, <span class="number">480</span>, <span class="number">192</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">64</span>)</span><br><span class="line">    ince4b = inception(<span class="string">"ince4b"</span>, ince4a, <span class="number">512</span>, <span class="number">160</span>, <span class="number">112</span>, <span class="number">224</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">    ince4c = inception(<span class="string">"ince4c"</span>, ince4b, <span class="number">512</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">    ince4d = inception(<span class="string">"ince4d"</span>, ince4c, <span class="number">512</span>, <span class="number">112</span>, <span class="number">144</span>, <span class="number">288</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">    ince4e = inception(<span class="string">"ince4e"</span>, ince4d, <span class="number">528</span>, <span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    pool4 = fluid.layers.pool2d(</span><br><span class="line">        input=ince4e, pool_size=<span class="number">3</span>, pool_type=<span class="string">'max'</span>, pool_stride=<span class="number">2</span>, pool_padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># stage 5</span></span><br><span class="line">    <span class="comment"># 2组inception+1个7*7最大池化层</span></span><br><span class="line">    ince5a = inception(<span class="string">"ince5a"</span>, pool4, <span class="number">832</span>, <span class="number">256</span>, <span class="number">160</span>, <span class="number">320</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    ince5b = inception(<span class="string">"ince5b"</span>, ince5a, <span class="number">832</span>, <span class="number">384</span>, <span class="number">192</span>, <span class="number">384</span>, <span class="number">48</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    pool5 = fluid.layers.pool2d(</span><br><span class="line">        input=ince5b,</span><br><span class="line">        pool_size=<span class="number">7</span>,</span><br><span class="line">        pool_stride=<span class="number">7</span>,</span><br><span class="line">        pool_type=<span class="string">"avg"</span>)</span><br><span class="line">    <span class="comment"># 添加丢弃概率为0.4的dropout层避免过拟合</span></span><br><span class="line">    drop1 = fluid.layers.dropout(x=pool5, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># 最后一层全连接层进行主损失率out的输出，softmax归一化每个类别的概率</span></span><br><span class="line">    out = fluid.layers.fc(</span><br><span class="line">        input=drop1, size=class_dim, act=<span class="string">'softmax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于计算损失率分量out1的第一个辅助的分类器</span></span><br><span class="line">    <span class="comment"># 5*5均值池化，注意这里的输入为ince4a的输出，也就是在生成out中途的输出</span></span><br><span class="line">    pool_o1 = fluid.layers.pool2d(</span><br><span class="line">        input=ince4a,</span><br><span class="line">        pool_size=<span class="number">5</span>,</span><br><span class="line">        pool_stride=<span class="number">3</span>,</span><br><span class="line">        pool_type=<span class="string">"avg"</span>,</span><br><span class="line">        pool_padding=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 1*1卷积</span></span><br><span class="line">    conv_o1 = fluid.layers.conv2d(</span><br><span class="line">        input=pool_o1,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=<span class="number">128</span>,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 带有激活函数RELU的全连接</span></span><br><span class="line">    fc_o1 = fluid.layers.fc(</span><br><span class="line">        input=conv_o1,</span><br><span class="line">        size=<span class="number">1024</span>,</span><br><span class="line">        act=<span class="string">"relu"</span>)</span><br><span class="line">    <span class="comment"># 添加丢弃概率为0.4的dropout层避免过拟合</span></span><br><span class="line">    drop2 = fluid.layers.dropout(x=fc_o1, dropout_prob=<span class="number">0.7</span>)</span><br><span class="line">    <span class="comment"># 最后一层全连接层softmax归一化后输出的out1</span></span><br><span class="line">    out1 = fluid.layers.fc(</span><br><span class="line">        input=drop2, size=class_dim, act=<span class="string">'softmax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于计算损失率分量out2的第二个辅助的分类器</span></span><br><span class="line">    <span class="comment"># 5*5均值池化，这里的输入为ince4d的输出，同样是在生成out中途的输出</span></span><br><span class="line">    pool_o2 = fluid.layers.pool2d(</span><br><span class="line">        input=ince4d,</span><br><span class="line">        pool_size=<span class="number">5</span>,</span><br><span class="line">        pool_stride=<span class="number">3</span>,</span><br><span class="line">        pool_type=<span class="string">"avg"</span>,</span><br><span class="line">        pool_padding=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 1*1卷积</span></span><br><span class="line">    conv_o2 = fluid.layers.conv2d(</span><br><span class="line">        input=pool_o2,</span><br><span class="line">        filter_size=<span class="number">1</span>,</span><br><span class="line">        num_filters=<span class="number">128</span>,</span><br><span class="line">        stride=<span class="number">1</span>,</span><br><span class="line">        padding=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 带有激活函数RELU的全连接</span></span><br><span class="line">    fc_o2 = fluid.layers.fc(</span><br><span class="line">        input=conv_o2,</span><br><span class="line">        size=<span class="number">1024</span>,</span><br><span class="line">        act=<span class="string">"relu"</span>)</span><br><span class="line">    <span class="comment"># 添加丢弃概率为0.4的dropout层避免过拟合</span></span><br><span class="line">    drop3 = fluid.layers.dropout(x=fc_o2, dropout_prob=<span class="number">0.7</span>)</span><br><span class="line">    <span class="comment"># 最后一层全连接层softmax归一化后输出的out1</span></span><br><span class="line">    out2 = fluid.layers.fc(</span><br><span class="line">        input=drop3, size=class_dim, act=<span class="string">'softmax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出损失率的三个分量</span></span><br><span class="line">    <span class="keyword">return</span> out, out1, out2</span><br></pre></td></tr></table></figure>
<h5 id="Inception-V4模型"><a href="#Inception-V4模型" class="headerlink" title="Inception-V4模型"></a>Inception-V4模型</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inception_v4模型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码来自：https://github.com/PaddlePaddle/models/blob/43cdafbb97e52e6d93cc5bbdc6e7486f27665fc8/PaddleCV/image_classification/models/inception_v4.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里使用了面向对象的封装</span></span><br><span class="line"><span class="comment"># 因为不同的inception版本中的同名函数例如conv_bn_layer（带batchnorm的卷积层）的具体实现是不同的</span></span><br><span class="line"><span class="comment"># 所以为了防止同名函数定义的互相覆盖，使用类的封装思想比较合理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InceptionV4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"using inception v4."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">net</span><span class="params">(self, input, class_dim=<span class="number">1000</span>)</span>:</span></span><br><span class="line">        <span class="comment"># STEP 1 inception_sterm模块</span></span><br><span class="line">        <span class="comment"># stem模块其实就是多次卷积＋２次池化，采用了Inception论文里提到的卷积＋池化并行的结构</span></span><br><span class="line">        <span class="comment"># 在同时也使用了多个1*1卷积，之前的googlenet（inception_v1）中也提到过</span></span><br><span class="line">        <span class="comment"># 这是一种降维操作，能够通过减少通道数从而减少因为并行结构带来的巨大计算量</span></span><br><span class="line">        x = self.inception_stem(input)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># STEP 2 4层inception_A模块+1层reduction模块</span></span><br><span class="line">        <span class="comment"># inception_A、B、C模块之间内在结构各有不同，在该算法论文中没有详细的解答，应该是一种经验性的结构</span></span><br><span class="line">        <span class="comment"># reduction起到了作为之前版本中的一层单层池化层的作用，同样采用了卷积+池化并行的结构</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            x = self.inceptionA(x, name=str(i + <span class="number">1</span>))</span><br><span class="line">        x = self.reductionA(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># STEP 3 7层inception_B模块+1层reduction模块</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">            x = self.inceptionB(x, name=str(i + <span class="number">1</span>))</span><br><span class="line">        x = self.reductionB(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># STEP 4 3层inception_C模块+1层reduction模块</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            x = self.inceptionC(x, name=str(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 平均池化，不同于最大池化提取特征，这是在保留背景信息</span></span><br><span class="line">        pool = fluid.layers.pool2d(</span><br><span class="line">            input=x, pool_size=<span class="number">8</span>, pool_type=<span class="string">'avg'</span>, global_pooling=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># dropout操作用来减少过拟合</span></span><br><span class="line">        drop = fluid.layers.dropout(x=pool, dropout_prob=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里做了一次运算，stdv是标准差的意思</span></span><br><span class="line">        stdv = <span class="number">1.0</span> / math.sqrt(drop.shape[<span class="number">1</span>] * <span class="number">1.0</span>)</span><br><span class="line">        <span class="comment"># 这里传入的initializer.Uniform是随机均匀分布初始化器的意思</span></span><br><span class="line">        <span class="comment"># 这里的全连接层的各个神经元权重使用了随机均匀分布初始化的方式</span></span><br><span class="line">        <span class="comment"># 一般的初始化方式有正态分布和随机均匀分布两种，两者优劣没有定论，但经验上看，均匀分布的随机数能够让更多的权重接近于0</span></span><br><span class="line">        out = fluid.layers.fc(</span><br><span class="line">            input=drop,</span><br><span class="line">            size=class_dim,</span><br><span class="line">            param_attr=ParamAttr(</span><br><span class="line">                initializer=fluid.initializer.Uniform(-stdv, stdv),</span><br><span class="line">                name=<span class="string">"final_fc_weights"</span>),</span><br><span class="line">            bias_attr=ParamAttr(</span><br><span class="line">                initializer=fluid.initializer.Uniform(-stdv, stdv),</span><br><span class="line">                name=<span class="string">"final_fc_offset"</span>),</span><br><span class="line">            act=<span class="string">'softmax'</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 带batchnorm的卷积层函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conv_bn_layer</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                      data,</span></span></span><br><span class="line"><span class="function"><span class="params">                      num_filters,</span></span></span><br><span class="line"><span class="function"><span class="params">                      filter_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                      stride=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      padding=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      groups=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      act=<span class="string">'relu'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                      name=None)</span>:</span></span><br><span class="line">        <span class="comment"># 和之前resnet使用的卷积层定义基本一致，只是添加了一些name名称，此处不再赘述</span></span><br><span class="line">        conv = fluid.layers.conv2d(</span><br><span class="line">            input=data,</span><br><span class="line">            num_filters=num_filters,</span><br><span class="line">            filter_size=filter_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            groups=groups,</span><br><span class="line">            act=<span class="literal">None</span>,</span><br><span class="line">            param_attr=ParamAttr(name=name + <span class="string">"_weights"</span>),</span><br><span class="line">            bias_attr=<span class="literal">False</span>,</span><br><span class="line">            name=name)</span><br><span class="line">        bn_name = name + <span class="string">"_bn"</span></span><br><span class="line">        <span class="comment"># batchnorm也是如此，基本一致</span></span><br><span class="line">        <span class="keyword">return</span> fluid.layers.batch_norm(</span><br><span class="line">            input=conv,</span><br><span class="line">            act=act,</span><br><span class="line">            name=bn_name,</span><br><span class="line">            param_attr=ParamAttr(name=bn_name + <span class="string">"_scale"</span>),</span><br><span class="line">            bias_attr=ParamAttr(name=bn_name + <span class="string">"_offset"</span>),</span><br><span class="line">            moving_mean_name=bn_name + <span class="string">'_mean'</span>,</span><br><span class="line">            moving_variance_name=bn_name + <span class="string">'_variance'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># inception_stem层，具体结构可以参考论文中的图像，</span></span><br><span class="line">    <span class="comment"># 基本原理还是和googlenet一样，并行处理的卷积+池化以及1*1卷积降维</span></span><br><span class="line">    <span class="comment"># 具体到结构为什么这么设计可以认为是经验性的，论文没有深入讨论</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inception_stem</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        conv = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">32</span>, <span class="number">3</span>, stride=<span class="number">2</span>, act=<span class="string">'relu'</span>, name=<span class="string">"conv1_3x3_s2"</span>)</span><br><span class="line">        conv = self.conv_bn_layer(conv, <span class="number">32</span>, <span class="number">3</span>, act=<span class="string">'relu'</span>, name=<span class="string">"conv2_3x3_s1"</span>)</span><br><span class="line">        conv = self.conv_bn_layer(</span><br><span class="line">            conv, <span class="number">64</span>, <span class="number">3</span>, padding=<span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"conv3_3x3_s1"</span>)</span><br><span class="line"></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=conv, pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">'max'</span>)</span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            conv, <span class="number">96</span>, <span class="number">3</span>, stride=<span class="number">2</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem1_3x3_s2"</span>)</span><br><span class="line">        concat = fluid.layers.concat([pool1, conv2], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            concat, <span class="number">64</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem2_3x3_reduce"</span>)</span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            conv1, <span class="number">96</span>, <span class="number">3</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem2_3x3"</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            concat, <span class="number">64</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem2_1x7_reduce"</span>)</span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            conv2,</span><br><span class="line">            <span class="number">64</span>, (<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_stem2_1x7"</span>)</span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            conv2,</span><br><span class="line">            <span class="number">64</span>, (<span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_stem2_7x1"</span>)</span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            conv2, <span class="number">96</span>, <span class="number">3</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem2_3x3_2"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([conv1, conv2], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            concat, <span class="number">192</span>, <span class="number">3</span>, stride=<span class="number">2</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_stem3_3x3_s2"</span>)</span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=concat, pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">'max'</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([conv1, pool1], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br><span class="line"></span><br><span class="line">    <span class="comment"># inception_A模块，同样不再赘述</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inceptionA</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=data, pool_size=<span class="number">3</span>, pool_padding=<span class="number">1</span>, pool_type=<span class="string">'avg'</span>)</span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            pool1, <span class="number">96</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_a"</span> + name + <span class="string">"_1x1"</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">96</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_a"</span> + name + <span class="string">"_1x1_2"</span>)</span><br><span class="line"></span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">64</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_a"</span> + name + <span class="string">"_3x3_reduce"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">96</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_a"</span> + name + <span class="string">"_3x3"</span>)</span><br><span class="line"></span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            data,</span><br><span class="line">            <span class="number">64</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_a"</span> + name + <span class="string">"_3x3_2_reduce"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">96</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_a"</span> + name + <span class="string">"_3x3_2"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">96</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_a"</span> + name + <span class="string">"_3x3_3"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([conv1, conv2, conv3, conv4], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reduction_A模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reductionA</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=data, pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">'max'</span>, pool_padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">384</span>, <span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_a_3x3"</span>)</span><br><span class="line"></span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">192</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_a_3x3_2_reduce"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3, <span class="number">224</span>, <span class="number">3</span>, padding=<span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_a_3x3_2"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3, <span class="number">256</span>, <span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_a_3x3_3"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([pool1, conv2, conv3], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br><span class="line"></span><br><span class="line">    <span class="comment"># inception_B模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inceptionB</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=data, pool_size=<span class="number">3</span>, pool_padding=<span class="number">1</span>, pool_type=<span class="string">'avg'</span>)</span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            pool1, <span class="number">128</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x1"</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">384</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x1_2"</span>)</span><br><span class="line"></span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">192</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x7_reduce"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">224</span>, (<span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x7"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_7x1"</span>)</span><br><span class="line"></span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            data,</span><br><span class="line">            <span class="number">192</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_7x1_2_reduce"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">192</span>, (<span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x7_2"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">224</span>, (<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_7x1_2"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">224</span>, (<span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_1x7_3"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_b"</span> + name + <span class="string">"_7x1_3"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([conv1, conv2, conv3, conv4], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br><span class="line"></span><br><span class="line">    <span class="comment"># reduction_B模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reductionB</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=data, pool_size=<span class="number">3</span>, pool_stride=<span class="number">2</span>, pool_type=<span class="string">'max'</span>, pool_padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">192</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_b_3x3_reduce"</span>)</span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            conv2, <span class="number">192</span>, <span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_b_3x3"</span>)</span><br><span class="line"></span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">256</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, padding=<span class="number">1</span>,name=<span class="string">"reduction_b_1x7_reduce"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">1</span>, <span class="number">7</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">3</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"reduction_b_1x7"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">320</span>, (<span class="number">7</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">3</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"reduction_b_7x1"</span>)</span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            conv3, <span class="number">320</span>, <span class="number">3</span>, stride=<span class="number">2</span>, act=<span class="string">'relu'</span>, name=<span class="string">"reduction_b_3x3_2"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat([pool1, conv2, conv3], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br><span class="line"></span><br><span class="line">    <span class="comment"># inception_C模块</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inceptionC</span><span class="params">(self, data, name=None)</span>:</span></span><br><span class="line">        pool1 = fluid.layers.pool2d(</span><br><span class="line">            input=data, pool_size=<span class="number">3</span>, pool_padding=<span class="number">1</span>, pool_type=<span class="string">'avg'</span>)</span><br><span class="line">        conv1 = self.conv_bn_layer(</span><br><span class="line">            pool1, <span class="number">256</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x1"</span>)</span><br><span class="line"></span><br><span class="line">        conv2 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">256</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x1_2"</span>)</span><br><span class="line"></span><br><span class="line">        conv3 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">384</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x1_3"</span>)</span><br><span class="line">        conv3_1 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x3"</span>)</span><br><span class="line">        conv3_2 = self.conv_bn_layer(</span><br><span class="line">            conv3,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_3x1"</span>)</span><br><span class="line"></span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            data, <span class="number">384</span>, <span class="number">1</span>, act=<span class="string">'relu'</span>, name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x1_4"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">448</span>, (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x3_2"</span>)</span><br><span class="line">        conv4 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">512</span>, (<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_3x1_2"</span>)</span><br><span class="line">        conv4_1 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">            padding=(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_1x3_3"</span>)</span><br><span class="line">        conv4_2 = self.conv_bn_layer(</span><br><span class="line">            conv4,</span><br><span class="line">            <span class="number">256</span>, (<span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">            padding=(<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">            act=<span class="string">'relu'</span>,</span><br><span class="line">            name=<span class="string">"inception_c"</span> + name + <span class="string">"_3x1_3"</span>)</span><br><span class="line"></span><br><span class="line">        concat = fluid.layers.concat(</span><br><span class="line">            [conv1, conv2, conv3_1, conv3_2, conv4_1, conv4_2], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> concat</span><br></pre></td></tr></table></figure>
<h4 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h4><p>为了能够更好地评价不同神经网络模型的训练性能、实际预测效果等，我们采用控制变量法，使用相同的训练和预测流程设计，训练使用的参数统一为batch_size=128、epoch=3，预测使用的待预测图像为一张狗的照片。运行程序、进行训练和预测的主要流程如下所示：</p>
<ul>
<li>首先，我们需要保证项目之前的输出被全部清空，且在“Kernel操作”中进行过至少一次的“重启”操作。</li>
<li>之后，在最后一个cell的程序主函数中的model变量中确定对应模型的名称，若只需要使用已生成的模型文件进行预测而不需要再次训练，可以注释掉train训练主函数，只运行predict预测主函数。</li>
<li>最后，选中第一个cell，点击“Notebook操作”中的“运行当前及下方所有”，开始程序的运行。</li>
</ul>
<p>各模型的具体运行结果截图可以参见下一章节“实验数据”。</p>
<h3 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h3><p>在训练和预测流程执行完毕后，对于各个模型程序输出的原始数据结果截图如下所示：</p>
<h4 id="VGG模型-1"><a href="#VGG模型-1" class="headerlink" title="VGG模型"></a>VGG模型</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/data-vgg.png" alt="VGG 模型的运行结果"></p>
<center>图 3.1 VGG模型的运行结果（仅训练数据输出）</center>

<p>可能是由于最终训练结果的精确度过低，在预测过程中出现了报错的情况，因此此处没有预测结果。</p>
<h4 id="ResNet模型-1"><a href="#ResNet模型-1" class="headerlink" title="ResNet模型"></a>ResNet模型</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/data-resnet.png" alt="ResNet 模型的运行结果"></p>
<center>图3.2 ResNet模型的训练和预测结果</center>

<h4 id="GoogleNet模型-1"><a href="#GoogleNet模型-1" class="headerlink" title="GoogleNet模型"></a>GoogleNet模型</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/data-googlenet.png" alt="GoogleNet 模型的运行结果"></p>
<center>图3.3 GoogleNet模型的训练和预测结果</center>

<h4 id="Inception-V4模型-1"><a href="#Inception-V4模型-1" class="headerlink" title="Inception-V4模型"></a>Inception-V4模型</h4><p>由于在理论上Inception-V4模型应当是GoogleNet（Inception-V1）的改进，但是首次训练和预测后的结果都完全差于GoogleNet，于是我们查询了该模型代码来源的GitHub仓库上的参数设置，发现batch_size应当由128改为256。</p>
<p>在针对该模型设置该特有参数值之后，我们进行了第二次的额外训练和预测。两次训练和预测的原始数据如下所示：</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/data-inception-v4-1.png" alt="Inception-v4 模型的首次运行结果"></p>
<center>图3.4 Inception-V4模型首次运行时的训练和预测结果</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/data-inception-v4-2.png" alt="Inception-v4 模型修改后的运行结果"></p>
<center>图3.5 Inception-V4模型修改batch_size之后<br>再次运行时的训练和预测结果</center>

<h3 id="实验数据处理"><a href="#实验数据处理" class="headerlink" title="实验数据处理"></a>实验数据处理</h3><h4 id="VGG模型数据图表"><a href="#VGG模型数据图表" class="headerlink" title="VGG模型数据图表"></a>VGG模型数据图表</h4><p>由于在“实验数据”环节所述的程序报错的关系，未能够通过python代码自动生成损失率图表，此处使用Excel生成相关图表：</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-vgg-1.png" alt="vgg 训练数据图表"></p>
<center>图4.1 VGG训练数据图表</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-vgg-2.png" alt="VGG 测试数据图表"></p>
<center>图4.2 VGG测试数据图表</center>

<p>可以看出，VGG模型在当前训练环境下，训练过程中损失率震荡较大，下降速率较慢，准确率同样在上下波动且上升速率较慢，而使用测试数据集生成的测试数据基本保持不变。而且准确率相当低，在10%左右徘徊，说明VGG模型在当前环境下的综合性能较差。</p>
<h4 id="ResNet模型数据图表"><a href="#ResNet模型数据图表" class="headerlink" title="ResNet模型数据图表"></a>ResNet模型数据图表</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-resnet-1.png" alt="vgg 损失率数据图表"></p>
<center>图4.3 实验程序生成的ResNet的训练和测试损失率图表</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-resnet-2.png" alt="vgg 准确率数据图表"></p>
<center>图4.4 ResNet的训练和测试准确率图表</center>

<p>ResNet模型在当前训练环境下，训练过程中损失率震荡较小，下降速率在训练初期较快，之后趋于平缓。虽然测试过程中的损失率虽然震荡较大，但是参照训练过程，确实维持在一个合理的区间内。</p>
<p>在训练和测试过程中，ResNet模型的准确率都保持着不断升高的趋势，最终的准确率接近70%。</p>
<p>但是，在实际的预测过程中，ResNet模型却将带预测的图片分类为了horse马，说明在实际应用过程中，该模型仍存在可以提升的空间。</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/dog-resnet.png" alt="restnet 实际预测结果"></p>
<center>图4.5 ResNet模型实际预测结果</center>

<h4 id="GoogleNet模型数据图表"><a href="#GoogleNet模型数据图表" class="headerlink" title="GoogleNet模型数据图表"></a>GoogleNet模型数据图表</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-googlenet-1.png" alt="googlenet 损失率数据图表"></p>
<center>图4.6 实验程序生成的GoogleNet的训练和测试损失率图表</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-googlenet-2.png" alt="googlenet 准确率数据图表"></p>
<center>图4.7 GoogleNet的训练和测试准确率图表</center>

<p>GoogleNet模型在当前训练环境下，训练过程中损失率几乎没有震荡，下降速率在训练初期极快，之后趋于平缓且不断逼近0。测试过程中的损失率曲线与训练过程曲线近乎重合。以上现象说明了在当前环境下，该模型的训练效果相当出色。</p>
<p>在训练和测试过程中，GoogleNet模型的准确率都保持着不断升高的趋势，最终的准确率在60%左右。</p>
<p>除了下降速率曲线之外，该模型还有如下2点令人印象深刻之处：</p>
<ul>
<li>训练速度快：相比其他模型，该模型的训练耗时相当少，当其他模型需要5~10秒才能训练完一个pass时，该模型只需1秒左右的时间，因此训练速度极快。我们认为训练速度快的主要原因是：该模型的网络层数相较于其他模型更少，且3个子网络分别输出损失率并加权求和的操作有助于优化器更加精确地计算出当前梯度，从而更准确地调整网络中各层神经元的权重参数。</li>
<li>模型实际预测结果精准：如下图所示，在实际预测的过程中，该模型是唯一一个将该图片正确分类为dog狗的，可以看出该模型在实际应用方面的准确度相当高，虽然数据层面的准确率60%略逊于ResNet的70%。</li>
</ul>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/dog-googlenet.png" alt="GoogleNet 模型实际预测结果"></p>
<center>图4.8 GoogleNet模型实际预测结果</center>

<h4 id="Inception-V4模型数据图表"><a href="#Inception-V4模型数据图表" class="headerlink" title="Inception-V4模型数据图表"></a>Inception-V4模型数据图表</h4><p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-inception-v4-1.png" alt="inception-v4 损失率数据图表"></p>
<center>图4.9 实验程序生成的Inception-V4的训练和测试损失率图表</center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-inception-v4-2.png" alt="inception-v4 损失率数据图表"></p>
<center>图4.10 Inception-V4的训练和测试准确率图表</center>

<p>Inception-V4模型在当前训练环境下，训练过程中损失率震荡严重，下降速率缓慢。测试过程中的损失率曲线与训练过程曲线同样近乎重合。以上现象说明了在当前环境下该模型训练效果较差。</p>
<p>在训练和测试过程中，Inception-V4模型的准确率都保持着不断升高的趋势，但是最终的准确率在30%左右。</p>
<p>在实际预测中，该模型将带预测图片分类为了truck卡车，说明其模型准确度确实不高。</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/dog-inception-v4-1.png" alt="Inception-v4 模型实际预测结果"></p>
<center>图4.11 Inception-v4 模型实际预测结果</center>

<p>我们在“实验数据”环节就已经根据程序输出的实验数据提出了“为何作为GoogleNet的迭代版本，Inception-V4反而在性能和实际效果上不如GoogleNet”的疑问并根据相关资料修改了batch_size为256，并进行了第二次的训练和预测。实验数据处理如下所示：</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-inception-v4-3.png" alt="修改后inception-v4 损失率数据图表"></p>
<center>图4.12 调整参数第二次训练后<br><br>实验程序生成的Inception-V4的训练和测试损失率图表<br></center>

<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/graph-inception-v4-4.png" alt="修改后inception-v4 准确率数据图表"></p>
<center>图4.13 调整参数第二次训练后<br><br>Inception-V4的训练和测试准确率图表<br></center>

<p>可以看出，Inception-V4模型在修改参数后的训练环境下，训练过程中损失率震荡有所收敛，但下降速率依旧缓慢。测试过程中的损失率曲线与训练过程曲线同样近乎重合。以上现象说明了在当前环境下该模型训练效果仍然较差。</p>
<p>在训练和测试过程中，Inception-V4模型的准确率都保持着不断升高的趋势，但是最终的准确率还是在30%左右。<br>在实际预测中，该模型将带预测图片分类为了automobile轿车，说明其模型准确度仍然不高</p>
<p><img src="/2019/06/29/Different-Deep-Learning-Methods-for-Image-Classification-on-CIFAR-10/dog-inception-v4-2.png" alt="修改后Inception-v4 模型实际预测结果"></p>
<center>图4.11 调整参数第二次训练后<br><br>GoogleNet模型实际预测结果<br></center>

<p>我们初步怀疑调整参数后效果仍然较差的原因有如下两点：</p>
<ul>
<li>epoch的次数仍然偏少，因为Inception_V4的网络层数明显多于GoogleNet，因此需要更长时间的训练才能够获得一个较好的模型，但由于使用CPU训练速度较慢，实验时间有限，暂时不考虑进行更多次的实验。</li>
<li>据Inception_V4对应的论文《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》中的描述，该模型的设计主要考虑到了TensorFlow等框架在内存分配等方面的优化设计，因此也存在着paddlepaddle不支持这些特性导致的模型性能表现的不佳。</li>
</ul>
<h3 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h3><h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>针对在“实验数据处理”章节中对实验数据的图表绘制处理和初步分析，我们能够得出以下综合分析结果：</p>
<ul>
<li>使用控制变量法在相同环境（尤其是采用相同参数）下的不同模型进行的性能评价结果，这一方法存在着很大的局限性。本次实验尤为突出的表现正是Inception系列的V1（GoogleNet）和V4之间的可以称之为逆转性的结果。在batch_size=128、epoch=3的条件下，V1在训练速度、训练数据展示的效果、实际预测效果上都优于V4。而出于对这一反常问题的好奇，我们将batch_size按照V4代码的初始来源处的参数改为了batch_size=256，结果效果改善程度有限。这些说明了控制变量法并不能够全面地衡量不同模型之间的性能和实际效果。</li>
<li>在当前环境下，GoogleNet和ResNet在各项实验数据指标上优于其他模型，而GoogleNet为最优。ResNet仅在准确率的数据层面上的70%略胜于GoogleNet的60%，而GoogleNet无论是在训练所需时间、损失率曲线的震荡程度、损失率曲线的下降速率、以及实际预测的准确程度都明显优于ResNet，且是唯一一个正确分类了带预测图片的模型。</li>
<li>但是这并不意味着Inception系列的Inception模块设计不存在缺陷，也并不意味着Inception系列不应该引入ResNet的结构设计，相反，ResNet的残差模块的结构设计在实际研究和应用过程中，确实有其“提升深层次网络训练结果的准确度和收敛速度”的独到之处。只不过由于实验时间的关系，我们并未继续引入Inception-ResNet-V1、Inception-ResNet-V2等两者相结合的模型，并进行进一步的实验和分析。</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><h5 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h5><p>本次实验基于百度AI Stuido平台的在线项目平台，使用了包括VGG、ResNet、GoogleNet（Inception-V1）、Inception-V4等图像分类神经网络模型以及CIFAR10数据集，对相同环境条件下的不同模型在训练和预测过程中的性能开销、数据指标变化情况、实际预测情况等进行了详细的分析讨论。尽管通过实验表明，本次实验所使用的控制变量法存在着一定的局限性，但是本次实验仍然得出了GoogleNet（代表Inception系列）、ResNet在性能指标和实际效果上较为优秀的结论，这肯定了Inception模块、残差模块的结构设计在模型训练、实际预测等多方面相较于传统的多层神经网络存在着相当大的优势。</p>
<p>本次实验目的步骤明确、实验过程较为顺利、对实验结果的也进行了较为细致的处理和分析，是一次虽然存在问题，但在一定程度上较为成功的人工智能课程实验。</p>
<h5 id="成果收获"><a href="#成果收获" class="headerlink" title="成果收获"></a>成果收获</h5><p>经过本次实验，我们团队成员收获了以下成果：</p>
<ul>
<li>通过研读paddlepaddle官方教程和文档以及其他网上相关资料、编写、移植以及逐行注释不同模型代码、处理分析实验数据等方式，我们锻炼了团队合作完成“查阅人工智能相关文献、理解相关基本概念、使用代码实现相应模型的结构设计、对实验数据进行处理和分析”的一整套人工智能领域研究流程的实战能力。</li>
<li>通过对paddlepaddle框架的学习，我们初步掌握了深度学习框架、以及其他辅助用途的python库的基本使用方式，了解了使用深度学习框架的需要进行的“数据处理、参数设置、模型训练、测试集测试、结果输出”等一般流程。</li>
<li>通过这次实验，我们也巩固了团队合作的情况下完成实验的任务分配、进度协调、成员沟通等综合能力。</li>
</ul>
<h5 id="待改进的地方"><a href="#待改进的地方" class="headerlink" title="待改进的地方"></a>待改进的地方</h5><p>经过本次实验，我们认为仍然存在以下待改进的地方：</p>
<ul>
<li>实验对不同模型的评估比较方法存在问题。控制单一变量法并不能够全面地让不同模型发挥出应有的性能效果，应当考虑给予不同模型以其目前研究水平下最佳的环境配置，通过基于单一测试数据的多次实际预测效果测试来衡量不同模型的性能，其结果会更好。</li>
<li>未能引入更多较为新型的图像分类模型例如Inception-ResNet系列模型等，进行范围更加广泛的比较和分析。</li>
</ul>
<h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>最后，在整篇文章的结尾，我还是要一如既往地感谢本次与我合作完成这一项目的搭档：Jet Lian，他主要负责本次项目的相关文献资料的查阅和汇总，VGG、ResNet、Inception-V4模型代码的编写、注释，实验程序执行和实验数据结果的处理、分析，“实验内容与步骤”之后的实验报告的撰写。</p>
<p>在他的合作之下，我才能够完成我自己的工作内容：实验方案选取、实验环境初始化、项目训练和预测函数等模块结构的搭建，基于paddlepaddle早期版本GoogleNet模型代码的移植、编写和注释，“实验内容与步骤”及之前的实验报告撰写。</p>
<p>作为室友兼搭档，我个人是十分敬佩他分析问题、解决问题和实际编码的强大综合能力的，像他这样成绩优秀且技术能力过硬的同学，在USTB的CS专业中乃至SCCE学院中都是罕见的。真的十分荣幸，能够在这三年的时光中与他为友，在技术成长的道路上并肩前行。</p>
<p>同时，我也十分感谢《人工智能》专业选修课的任课老师王睿老师、以及本次和AI专选课合作的百度AI Studio在线实验平台，正是老师和工作人员们的通力合作和不懈努力，为我们本届CS学生创造了一次实际体验深度学习训练到预测全过程的宝贵机会。希望这样的机会在未来的SCCE学院乃至整个行业会越来越多，再次感谢这些为技术知识的传播做出贡献的人们！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>百度paddlepaddle官网教程《深度学习基础教程》的《图像分类》章节：<br><a href="http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html" target="_blank" rel="noopener">http://paddlepaddle.org/documentation/docs/zh/1.4/beginners_guide/basics/image_classification/index.html</a></li>
<li>基于paddlepaddle的inception-v4模型代码：<br><a href="https://github.com/PaddlePaddle/models/blob/43cdafbb97e52e6d93cc5bbdc6e7486f27665fc8/PaddleCV/image_classification/models/inception_v4.py" target="_blank" rel="noopener">https://github.com/PaddlePaddle/models/blob/43cdafbb97e52e6d93cc5bbdc6e7486f27665fc8/PaddleCV/image_classification/models/inception_v4.py</a></li>
<li>基于paddlepaddle旧版的googlenet模型（本文中展示的是基于该项目移植到新版paddlepaddle后的代码）：<br><a href="https://www.cnblogs.com/charlotte77/p/8066867.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlotte77/p/8066867.html</a></li>
<li>Google Inception系列论文《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》：<br><a href="https://www.aaai.org/ocs/index.php/AAAI/AAAI17/paper/viewPDFInterstitial/14806/14311" target="_blank" rel="noopener">https://www.aaai.org/ocs/index.php/AAAI/AAAI17/paper/viewPDFInterstitial/14806/14311</a></li>
</ol>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes About Recent Projects 3</title>
    <url>/2018/06/28/Notes-About-Recent-Projects-3/</url>
    <content><![CDATA[<blockquote>
<p>The most stupid work<br>might be the most important one to cherish.</p>
</blockquote>
<p>此处收录一些近期的项目笔记，<br>这次真的是最近正在干的事情了。</p>
<a id="more"></a>
<p>没上锁的原因？<br>是因为我从校会网络部光荣退休了吧。。。<br>讲点别的项目。</p>
<h2 id="贝壳计通讲师团"><a href="#贝壳计通讲师团" class="headerlink" title="贝壳计通讲师团"></a>贝壳计通讲师团</h2><p>项目访问方式：</p>
<p><img src="https://raw.githubusercontent.com/lmy98129/weapp-ustb/master/QRCODE.jpg" alt="QRCODE"></p>
<ol>
<li>扫描上方的小程序码</li>
<li>微信小程序搜索“贝壳计通讲师团”</li>
<li><a href="https://github.com/lmy98129/weapp-ustb" target="_blank" rel="noopener">Github</a></li>
</ol>
<h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP1.PNG" alt="WEAPP1"></p>
<p><center>小程序主界面，更多预览请直接打开小程序或阅读本文后续内容</center><br></p>
<p>这是北京科技大学计算机与通信工程学院学生讲师团的官方小程序，管理方是北京科技大学计算机与通信工程学院学生讲师团，开发和维护方是北京科技大学计算机与通信工程学院的计算机科学与技术专业大二学生本人以及我的搭档fafnir，<strong>本人作为小程序的主要开发者之一，完成了本小程序的数据库结构设计、前端小程序开发、Node.js后端开发工作，并进行了多次版本迭代</strong>。搭档fafnir完成的工作主要为开发基于Python的Django Xadmin搭建的小程序后台管理网站。</p>
<p>项目创建的具体时间应与本博客的创建时间相差不多，开发时间长达3个月，上线时间已达1个月，经历两次大改。目前最新版本为v0.4.1。<br><strong>小程序前端基于腾讯微信小程序开发工具的原生组件，后端基于Node.js框架Express，数据库使用MySQL，数据库访问使用Node.js的MySQL库。其中，前端的通信模块以及后端的数据库访问模块均采用Promise异步编程封装。</strong></p>
<blockquote>
<p>注：我们计划在将本程序进行适当重构后，将本程序的前后端代码适时发布至GitHub。<br>当前程序内的敏感信息较多，公布后风险较大故暂不考虑。</p>
<p>后续：前端代码已发布至<a href="https://github.com/lmy98129/weapp-ustb" target="_blank" rel="noopener">Github</a></p>
</blockquote>
<h3 id="项目技术细节"><a href="#项目技术细节" class="headerlink" title="项目技术细节"></a>项目技术细节</h3><p>本项目的最初需求来源是：在2017秋季学期计通学院学生讲师团旧有线上预约平台网站开发维护人员即将毕业离校，讲师团负责人员联系辅导员提出了寻找学生进行下一代线上辅导预约平台的开发和维护工作的需求，最终确定采用小程序的形式进行开发，并招募了开发人员。原定计划为寒假一个多月时间内完成开发任务，但由于人员技术水平有限，以及在开发过程中遇到的种种挫折，我们前后花费了将近3个月的时间，经历两次大改才将目前接近成品的版本v0.4.1付诸上线使用。</p>
<h4 id="项目第一版"><a href="#项目第一版" class="headerlink" title="项目第一版"></a>项目第一版</h4><p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP2.PNG" alt="WEAPP2"></p>
<p><center>第一版小程序主界面，更多预览请阅读本文后续内容</center><br></p>
<p>项目的第一版完成了基本的需求分析、技术选型、数据库表设计、设备部署以及初步的技术实现等工作。其中需求分析与数据库表设计均由我来完成，并根据MySQL的通行命名规范，编写了本项目的第一份需求分析以及数据库表结构稿件。<strong>出于安全考虑，不在此处公布数据库各表的具体字段。</strong>由于我们与需求方之间初期的沟通较少，导致我们对于需求方的理解有一定的偏差，但根据我们之后的需求更改情况，可以看出大方向上是无误的。</p>
<h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>我们在第一版设计时的具体需求（大部分为开发方在开发过程中，帮助需求方总结的需求）为：</p>
<ul>
<li>小程序前端搭载学生端和讲师端两套代码，在用户登录过程中，使用微信提供的用户id查询数据库结果决定显示哪一界面，普通用户默认为学生用户。（虽然在历次提交审查中，<strong>微信方面的小程序测试人员并未对此提出任何疑问</strong>，但可以说确实是一种逃避审查的潜在手段，希望微信方面改进审查机制加以防范）</li>
<li>讲师发布课程内容，包括课程名称、日期、时间、地点、人数上限、备注等，其中人数上限、地点、备注为选填项。（<strong>早期版本中未考虑到人数上限问题，是后期加入的字段</strong>）</li>
<li>学生可以进入课程列表对讲师发布的课程进行预约或取消预约，其中达到人数上限、课程取消等情况下提示学生不得预约，课程列表发生的更改将在触发课程列表本身更改的同时，实时触发首页列表的刷新。（<strong>课程超时不得预约的功能较为复杂，也是后期加入的字段</strong>）</li>
<li>学生端以及讲师端首页均显示自己已预约的课程或已发布的课程情况，以及对课程进行相应的编辑操作：学生可以取消课程预约，讲师可以取消、删除、编辑课程，讲师的编辑操作也将触发其首页列表的刷新。</li>
<li>在课程列表以及首页中点击单个课程卡片可以查看课程详情。</li>
<li>“我的”页面中普通学生用户可以申请成为讲师，需提交真实姓名以及电话号码，通过后台管理网站的管理员核对后通过认证成为讲师。</li>
<li>后台管理网站应该能自由编辑、删除任何讲师发布的课程，应在开发后期对讲师每月授课情况统计，并进行展示（<strong>截至文章发布，授课情况统计功能暂未全部完成</strong>）。</li>
</ul>
<h5 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h5><p>根据以上的需求分析，大致能够分成以下的数据库表（具体字段不予公布）</p>
<ol>
<li>用户预约总表</li>
<li>讲师课程列表</li>
<li>管理员认证讲师资格列表</li>
<li>管理员账户列表</li>
</ol>
<h5 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h5><p>从这些数据库表可以分析得出的功能表如下：</p>
<ol>
<li>用户<ol>
<li>查看当前可预约课程列表</li>
<li>提交预约</li>
<li>取消预约</li>
<li>查看自己当前的预约</li>
<li>提交讲师认证申请</li>
</ol>
</li>
<li>讲师<ol>
<li>查看当前已发布课程以及预约情况（预约人数）</li>
<li>提交课程</li>
<li>取消课程</li>
<li>修改课程</li>
</ol>
</li>
<li>管理员<ol>
<li>查看并编辑当前所有课程以及预约</li>
<li>操作讲师认证申请</li>
<li>查看当前所有讲师每月的授课情况</li>
</ol>
</li>
</ol>
<h5 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h5><p>项目第一版的技术选型由fafnir完成，总体情况是采用了腾讯云提供的<a href="https://github.com/tencentyun/wafer" target="_blank" rel="noopener">wafer小程序一站式解决方案</a>，具体来说应该是wafer1，选择的理由是相比于wafer2中服务器无法取得完整访问权的形式，wafer1可以直接在服务器上部署后台管理网站。（<strong>虽然后来的经费结算显示，使用wafer2方案可能会更经济一些</strong>，而且截至文章发布，腾讯云已经不再主推wafer1，并撤换下了多个wafer小程序一站式解决方案的访问入口，当前能够全新购买的解决方案的只剩下基于开发者工具的wafer2方案，两者之间的不同以及基本架构可以<a href="https://cloud.tencent.com/developer/article/1007109" target="_blank" rel="noopener">看这里</a>）当时的具体项目选型如下：</p>
<table>
<thead>
<tr>
<th>技术模块</th>
<th>采用技术</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>小程序前端</td>
<td>wafer小程序一站式解决方案小程序demo</td>
<td><a href="https://github.com/tencentyun/wafer-client-demo" target="_blank" rel="noopener">项目地址</a>，与后端通信采用的是<a href="https://github.com/tencentyun/wafer-client-sdk" target="_blank" rel="noopener">wafer自带的腾讯云SDK</a>，采用的是基于socket的全双工信道通信，部分界面元素直接复用了demo中的界面</td>
</tr>
<tr>
<td>服务器后端</td>
<td>wafer小程序站式解决方案Node.js后端demo</td>
<td><a href="https://github.com/tencentyun/wafer-node-server-demo" target="_blank" rel="noopener">项目地址</a>，部署于wafer一站式解决方案的业务服务器上，基于Node.js框架Express，与前端通信采用的同样是<a href="https://github.com/tencentyun/wafer-node-server-sdk" target="_blank" rel="noopener">wafer自带的腾讯云SDK</a>，采用的是基于socket的全双工信道通信，前后端的会话通信可以直接通过API地址进行，但是信道通信必须经过一站式解决方案的信道服务器进行（<strong>请记住这一点，在之后的版本迭代中就发生了问题</strong>），与数据库通信采用的是Node.js的MySQL库的线程池模式（<strong>此时并未对其进行任何的封装</strong>）</td>
</tr>
<tr>
<td>数据库</td>
<td>MySQL 5.6</td>
<td>部署于wafer一站式解决方案的云数据库上，通过wafer一站式解决方案的信道服务器进行远程访问</td>
</tr>
<tr>
<td>后台管理网站</td>
<td>基于Python的Django Xadmin</td>
<td>部署于wafer一站式解决方案的业务服务器上，与后端访问操作同一数据库</td>
</tr>
</tbody>
</table>
<h5 id="开发难点及笔记"><a href="#开发难点及笔记" class="headerlink" title="开发难点及笔记"></a>开发难点及笔记</h5><h6 id="JavaScript的异步单线程特性"><a href="#JavaScript的异步单线程特性" class="headerlink" title="JavaScript的异步单线程特性"></a>JavaScript的异步单线程特性</h6><p>由于对Node.js乃至JavaScript的异步单线程的特性，尤其是回调函数的理解还较为浅薄（可能也是在之前并未直接接触过前后端通信以及数据库通信的原因造成的。是的我之前的工作真的就是改改开源PHP项目的代码，没怎么认真研读过代码以及文档），所以在设计后端服务器与数据库通信模块时，仍然将思路停留在C/C++之类的线性思路上，例如有如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="string">'nothing'</span>;</span><br><span class="line">connection.query(<span class="string">"USE "</span>+database);</span><br><span class="line">connection.query(<span class="string">'SELECT * FROM '</span>+databaseForm, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    <span class="keyword">if</span> (results) &#123;</span><br><span class="line">        res = results;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure></p>
<p>其执行结果按照我的想象应该是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nothing</span><br><span class="line">(查询的结果)</span><br><span class="line">(查询的结果)</span><br></pre></td></tr></table></figure></p>
<p>结果是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nothing</span><br><span class="line">(查询的结果)</span><br><span class="line">nothing</span><br></pre></td></tr></table></figure></p>
<p>相当于查询结果并未真正传给变量<code>res</code>，若我想在第二个<code>console.log(res);</code>的位置进行查询结果向前端的回传，则回传的结果将仍是<code>nothing</code>。具体原因？简单来说就是JavaScript作为一种在浏览器引擎中工作的语言，在大多数情况下只能单线程运行，此时只能先将一些阻塞整个线程运行的工作进行挂起处理（就例如前后端通信，若后端在某次查询时迟迟不回传，不应该将这个查询之外的其他工作全部停止，选择等待查询结果的到来，而是将其挂起，当后端查询结果回传时，再回过头来进行查询结果的处理等与查询结果相关的工作），这个挂起处理就是通过回调函数<code>callback</code>实现的，也就是上面第二个<code>connection.query</code>中的<code>function</code>函数。因此，正确的实现应该是:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">connection.query(<span class="string">"USE "</span>+database);</span><br><span class="line">connection.query(<span class="string">'SELECT * FROM '</span>+databaseForm, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    <span class="keyword">if</span> (results) &#123;</span><br><span class="line">        TunnelService.emit(tunnelId, messageId, results); <span class="comment">//直接在回调函数中进行回传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h6 id="Node-js中MySQL库的单语句查询、参数化查询等防注入机制"><a href="#Node-js中MySQL库的单语句查询、参数化查询等防注入机制" class="headerlink" title="Node.js中MySQL库的单语句查询、参数化查询等防注入机制"></a>Node.js中MySQL库的单语句查询、参数化查询等防注入机制</h6><p>后端服务器与MySQL通信使用的库为Node.js通用的MySQL库，安装命令为<code>npm install mysql</code>。根据我们后期的开发经验，事实上不应该使用该库而应该使用更加专业的ORM框架（<a href="https://baike.baidu.com/item/ORM/3583252" target="_blank" rel="noopener">ORM的定义</a>）来方便我们对数据库操作命令进行js化的直接编写，而非只用SQL语句进行直接查询，虽然学习SQL语句也不是一件坏事。是的，本项目基本上用到的也就是增删改查、左联右联内联、COUNT计数、建表建库等基本SQL语句。</p>
<p>但是，问题在于该MySQL库本身的最佳实践中提到了其参数化查询、单语句查询的等防注入攻击的机制。其中参数化查询并非开发难点，此处可以略过，但是其默认单语句查询的功能实在是增加了开发难度。也就是必须在单条SQL语句当中完成所有查询，不允许进行多次查询后通过中间变量进行合并得到最终结果。这一设定的出发点是好的，万一API接口被传入一些带“;”的参数，且允许多语句查询，我们并不知道这些参数是否会导致SQL注入攻击的发生。</p>
<p>诚然，大多数查询通过本人的努力都实现了单语句查询的效果，虽然SQL语句看起来又臭又长，外人难以读懂（这也是我反思之后决定日后学习ORM的主要原因之一）。但是若出现某些根据上一次查询结果进行分支操作的情况，单语句查询就显得十分吃力了。例如，我们遇到了这一种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">    &quot;开始查询&quot;--&gt;&quot;查询某记录是否存在&quot;</span><br><span class="line">    if &quot;该记录存在吗？&quot; then</span><br><span class="line">        --&gt; [yes] &quot;将原记录的删除状态解除并修改其内容&quot;</span><br><span class="line">        --&gt; &quot;返回结果&quot;</span><br><span class="line">    else</span><br><span class="line">        --&gt; [no] &quot;新增一条记录&quot;</span><br><span class="line">        --&gt; &quot;返回结果&quot;</span><br><span class="line">    endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p><center>如果因SSL证书问题无法查看上方的流程图，可以使用其他非Chrome内核的浏览器或使用桌面端浏览器阅读本文</center><br></p>
<p>所以在项目的第一版中，我们采用了Node.js的<code>async</code>库中的<code>waterfall</code>进行同步顺序编程，<br><strong>之后的版本我发现了Promise是个好东西（虽然理解起来有难度）</strong><br><strong>然后就把通信模块统统重写了个遍</strong><br>在MySQL通信模块中解决这一问题的一个库函数实例如下：<br>也可以看出采用了参数化查询的防注入机制，以及MySQL的线程池。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> mysqlReserveClassStu(tunnelId, messageId, openId, classId, nickName) &#123;</span><br><span class="line">  <span class="keyword">var</span> tasks = [<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">error,connection</span>) </span>&#123;</span><br><span class="line">      connection.query(<span class="string">"SELECT * FROM user_reserve WHERE class_id=? AND user_id=?"</span>, [classId, openId], <span class="function"><span class="keyword">function</span> (<span class="params">error, results_1, fields</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">        <span class="keyword">if</span> (results_1) &#123;</span><br><span class="line">          connection.release();</span><br><span class="line">          callback(error, results_1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">results_1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(results_1[<span class="number">0</span>] == <span class="literal">null</span>)&#123;</span><br><span class="line">      pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">error,connection</span>) </span>&#123;</span><br><span class="line">        connection.query(<span class="string">"INSERT INTO user_reserve (user_id,user_nickname,class_id,submission_date) VALUES(?,?,?,NOW())"</span>,</span><br><span class="line">        [openId,nickName,classId], <span class="function"><span class="keyword">function</span>(<span class="params">error, results_2, fields</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(error) <span class="keyword">throw</span> error;</span><br><span class="line">          <span class="keyword">if</span>(results_2) &#123;</span><br><span class="line">            connection.release();</span><br><span class="line">            TunnelService.emit(tunnelId, messageId, results_2);</span><br><span class="line">            callback(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">error,connection</span>) </span>&#123;</span><br><span class="line">        connection.query(<span class="string">"UPDATE user_reserve SET status=1 WHERE class_id=? AND user_id=?"</span>,</span><br><span class="line">        [classId,openId], <span class="function"><span class="keyword">function</span>(<span class="params">error,results_3, fields</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(error) <span class="keyword">throw</span> error;</span><br><span class="line">          <span class="keyword">if</span>(results_3) &#123;</span><br><span class="line">            connection.release();</span><br><span class="line">            TunnelService.emit(tunnelId, messageId, results_3);</span><br><span class="line">            callback(error);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>.waterfall(tasks, <span class="function"><span class="keyword">function</span>(<span class="params">error, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error) <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个代码块确定没把数据库表的字段抖出来了吗。。。<br>emmmm，还好吧。各位高抬贵手，高抬贵手。。。</p>
</blockquote>
<h6 id="前端、后端、数据库三者之间的时间不统一以及时间格式的处理问题"><a href="#前端、后端、数据库三者之间的时间不统一以及时间格式的处理问题" class="headerlink" title="前端、后端、数据库三者之间的时间不统一以及时间格式的处理问题"></a>前端、后端、数据库三者之间的时间不统一以及时间格式的处理问题</h6><p>这里由于我自己也记不大清楚当初的处理思路（尤其是小程序前端在处理过程中使用的“幻数”），<br>很可能都是我无意识情况下的“瞎调试”的成果。<br><strong>这个说实话我是极其不提倡这么干的，虽然有的时候的确有用</strong><br>此处提供各模块的关键代码供大家参阅：<br>服务器后端MySQL通信模块上的初始化操作，关键就是设置时区到正确的时间<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.env.TZ = <span class="string">'Asia/Shanghai'</span>;</span><br><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlExecute</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> mysqlInit() &#123;</span><br><span class="line">    pool = mysql.createPool(&#123;</span><br><span class="line">    connectionLimit: <span class="number">10</span>,</span><br><span class="line">    host     : mysqlHost,</span><br><span class="line">    user     : mysqlUser,</span><br><span class="line">    password : mysqlPassword,</span><br><span class="line">    database : mysqlDatabase,</span><br><span class="line">    timezone : process.env.TZ</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小程序前端的时间处理相关代码format，关键就是正则表达式+暴力剪切+暴力连接<br>（其中用了微信开发者工具的默认小程序demo里面的util.js时间处理函数）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> utils = <span class="built_in">require</span>(<span class="string">'./util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentDate = utils.formatTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="keyword">var</span> currentDateAnnual = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> classContentStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeFormat = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> start = str[i].class_timestart;</span><br><span class="line">        <span class="keyword">var</span> end = str[i].class_timend;</span><br><span class="line">        <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(str[i].class_date.slice(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">        date = date.getFullYear() + <span class="string">"年"</span> +</span><br><span class="line">        (<span class="built_in">parseInt</span>(date.getMonth()) + <span class="number">1</span>).toString() + <span class="string">"月"</span> +</span><br><span class="line">        date.getDate() + <span class="string">"日"</span>;</span><br><span class="line">        start = start.slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> (start.slice(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">"0"</span>) &#123;</span><br><span class="line">            start = start.slice(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">            end = end.slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> (end.slice(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">"0"</span>) &#123;</span><br><span class="line">            end = end.slice(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        str[i].class_date = date;</span><br><span class="line">        str[i].class_timestart = start;</span><br><span class="line">        str[i].class_timend = end</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dateFormat = <span class="function">(<span class="params">options, that</span>) =&gt;</span> &#123;</span><br><span class="line">    that.setData(&#123; </span><br><span class="line">        dateIndex: currentDate,</span><br><span class="line">        ateLimitStart: currentDate,</span><br><span class="line">    &#125;);</span><br><span class="line">    currentDateAnnual.setFullYear(currentDateAnnual.getFullYear() + <span class="number">1</span>);</span><br><span class="line">    currentDateAnnual.setDate(currentDateAnnual.getDate() - <span class="number">1</span>);</span><br><span class="line">    that.setData(&#123; <span class="attr">dateLimitEnd</span>: currentDateAnnual &#125;);</span><br><span class="line">    <span class="keyword">if</span> (options.class_content != <span class="literal">null</span>) &#123;</span><br><span class="line">        classContentStr = <span class="built_in">JSON</span>.parse(options.class_content);</span><br><span class="line">        <span class="keyword">if</span> (classContentStr.student_limit == <span class="string">'0'</span>) &#123;</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">                studentLimit: <span class="string">''</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">                studentLimit: classContentStr.student_limit</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        classContentStr.class_date = classContentStr.class_date.replace(<span class="string">"年"</span>, <span class="string">"-"</span>);</span><br><span class="line">        classContentStr.class_date = classContentStr.class_date.replace(<span class="string">"月"</span>, <span class="string">"-"</span>);</span><br><span class="line">        classContentStr.class_date = classContentStr.class_date.replace(<span class="string">"日"</span>, <span class="string">""</span>);</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">            className: classContentStr.class_name,</span><br><span class="line">            classIntro: classContentStr.class_intro,</span><br><span class="line">            dateIndex: classContentStr.class_date,</span><br><span class="line">            classPlace: classContentStr.class_place,</span><br><span class="line">            timeEndIndex: classContentStr.class_timend,</span><br><span class="line">            timeStartIndex: classContentStr.class_timestart,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classContentStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    timeFormat: timeFormat,</span><br><span class="line">    dateFormat: dateFormat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>看着相当的难受啊，这x一样的代码风格😂<br>没毛病，（下一版）会改的会改的🙏<br>（没错，之后的版本我直接把那个又臭又长的<code>classContentStr</code>给改了。。。）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(str[i].class_date.slice(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line"> <span class="comment">//这里得到的结果格式应该类似于yyyy-mm-dd</span></span><br><span class="line">date = date.getFullYear() + <span class="string">"年"</span> +</span><br><span class="line">        (<span class="built_in">parseInt</span>(date.getMonth()) + <span class="number">1</span>).toString() + <span class="string">"月"</span> +</span><br><span class="line">        date.getDate() + <span class="string">"日"</span>;</span><br></pre></td></tr></table></figure>
<p>想看幻数的同学看上面，我把它截取下来了。<br>是这样的：月份数诡异地被我加了一个1，然后居然就对了。。。<br>我也不知道这个到底是怎么一回事，在JavaScript里有什么奇异的原理导致了这个结果，有人知道的话可以告诉我吗?</p>
<blockquote>
<p>后续：我查到了，因为getMonth()是以数组形式来存储月份的，下标是0~11</p>
</blockquote>
<h6 id="人数上限的数据格式转换，以及人数已满等状态下阻止用户预约"><a href="#人数上限的数据格式转换，以及人数已满等状态下阻止用户预约" class="headerlink" title="人数上限的数据格式转换，以及人数已满等状态下阻止用户预约"></a>人数上限的数据格式转换，以及人数已满等状态下阻止用户预约</h6><blockquote>
<p>你还别说，我一边写这个笔记，一边还在最新版本的小程序里发现各种蜜汁有趣的bug呢😂</p>
</blockquote>
<p>人数上限作为讲师发布课程时的一个选填项，可以说是本项目数据处理的一个难点，其处理方式在本项目中也起到了一种模范的形式<br>难点在于：人数上限分为两种情况：“无上限”和存在数字上限，我们只能利用0这个数字来表示“无上限”，因为基本上不可能开设一个人也没有的课程，至少的人数上限也应该是1。但是反过来说，用户在填写表单时不可能特别将无上限填写为0，这在用户体验上只有留空才更加符合一般的表单填写习惯。</p>
<p>所以我们在用户点击上传按钮触发的函数中就将人数上限进行处理转换：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentLimitFormat;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.data.studentLimit == <span class="string">''</span>)&#123;</span><br><span class="line">    studentLimitFormat = <span class="string">'0'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    studentLimitFormat = <span class="keyword">this</span>.data.studentLimit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//之后传到后端的就是studentLimitFormat</span></span><br></pre></td></tr></table></figure></p>
<p>并在从后端回传的过程中也一样进行相应的处理，这里以课程内容页代码为例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(classContentStr.student_limit == <span class="string">'0'</span>)&#123;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    studentLimit: <span class="string">'无上限'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    studentLimit: classContentStr.student_limit</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，也应当在人数已满时阻止用户预约。在微信小程序中，我们使用<code>&lt;block wx:if&gt;</code>的wxml标签形式进行分类，通过条件判断来决定显示何种按钮，并只在“预约”和“取消预约”按钮上添加相应的函数钩子，这里以课程列表的上传按钮为例：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;item.student_sum &gt;= item.student_limit &amp;&amp; item.student_limit &gt; 0&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"reserve-button"</span> <span class="attr">data-content</span>=<span class="string">'&#123;&#123;item&#125;&#125;'</span>&gt;</span></span><br><span class="line">        人数已满</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;item.status == 0&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"reserve-button"</span> <span class="attr">data-content</span>=<span class="string">'&#123;&#123;item&#125;&#125;'</span>&gt;</span></span><br><span class="line">        已取消</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;item.reserve_status == null || item.reserve_status != 1&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"reserve-button"</span> <span class="attr">bindtap</span>=<span class="string">"bindReserve"</span> <span class="attr">data-content</span>=<span class="string">'&#123;&#123;item&#125;&#125;'</span>&gt;</span></span><br><span class="line">        预约</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;item.reserve_status == 1&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"reserve-button"</span> <span class="attr">bindtap</span>=<span class="string">"bindCancelReserve"</span> <span class="attr">data-content</span>=<span class="string">'&#123;&#123;item&#125;&#125;'</span>&gt;</span>          </span><br><span class="line">        取消预约</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当然，我们也在后端数据库表的设计中，将讲师课程表的人数上限字段的默认值设置为0。这算是最后一道防线吧，防止其他非法输入对数据的影响。</p>
<h6 id="提交表单前的各种格式检查"><a href="#提交表单前的各种格式检查" class="headerlink" title="提交表单前的各种格式检查"></a>提交表单前的各种格式检查</h6><p>是的，以人数上限的数据上传前进行处理为范本，我们普遍采用了<code>if() { return; }</code>的形式对非法输入进行检查，而这些非法输入的多样性之丰富，远远超出了我们的想象。例如：<br>有时间的非法输入，直接用正则表达式替换掉时间中的冒号+暴力的数字比较（<code>new Date</code>说实话多此一举了）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.data.timeStartIndex.replace(<span class="regexp">/:/g</span>, <span class="string">""</span>)) &gt; <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.data.timeEndIndex.replace(<span class="regexp">/:/g</span>, <span class="string">""</span>)))&#123;</span><br><span class="line">    wx.showModal(&#123;</span><br><span class="line">        title: <span class="string">'提示'</span>,</span><br><span class="line">        content: <span class="string">'开始时间应小于结束时间'</span>,</span><br><span class="line">        showCancel: <span class="literal">false</span>,</span><br><span class="line">        confirmColor: <span class="string">'#17abe3'</span>,</span><br><span class="line">        confirmText: <span class="string">'好的'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有人数上限输入非数字时，调用<code>isNaN()</code>函数的同时防止将留空代表“无上限”也拦截：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="keyword">this</span>.data.studentLimit) &amp;&amp; !(<span class="keyword">this</span>.data.studentLimit == <span class="literal">undefined</span>)) &#123;</span><br><span class="line">    wx.showModal(&#123;</span><br><span class="line">        title: <span class="string">'提示'</span>,</span><br><span class="line">        content: <span class="string">'人数上限应输入数字'</span>,</span><br><span class="line">        showCancel: <span class="literal">false</span>,</span><br><span class="line">        confirmColor: <span class="string">'#17abe3'</span>,</span><br><span class="line">        confirmText: <span class="string">'好的'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至对是否产生了无效的预约时间也进行了合法性检查：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((currentDate &gt; selectedDate) || ((currentDate == selectedDate) &amp;&amp; (currentTime &gt; selectedTime)) &#123;</span><br><span class="line">    wx.showModal(&#123;</span><br><span class="line">        title: <span class="string">'提示'</span>,</span><br><span class="line">        content: <span class="string">'预约时间应大于当前时间'</span>,</span><br><span class="line">        showCancel: <span class="literal">false</span>,</span><br><span class="line">        confirmColor: <span class="string">'#17abe3'</span>,</span><br><span class="line">        confirmText: <span class="string">'好的'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在合法性检查上花费了大量的时间，但也只能够对非法情况进行枚举性质的检测，若有一些我们不了解的业界最佳实践，欢迎联系我们探讨这一问题。</p>
<h5 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h5><p>程序测试确实是开发过程当中的重要一环，由于团队资源有限，且微信账号确实具有不可模拟性，所以我们在不足以拿到足够的微信测试账号以及测试机时，借助微信开发者工具和自己的手机号，建立了一个仅有两个核心测试账号、一台安卓测试机的测试体系（后期在发现iOS独有bug时，我们也找了临时的iPhone测试机和测试微信账号）。</p>
<ul>
<li>两个测试账号一个默认为普通学生用户，另一个通过后台管理网站通过讲师认证注册为讲师（在后台管理网站还未部署时，其实是通过手工向数据库表加入记录实现的），两号均在微信公众平台上注册为开发者</li>
<li>一般情况下，在PC端微信开发者工具上登录其中一个用户，手机端也登录这一用户，以测试学生端或讲师端在开发者工具的模拟器和实机上效果是否一致，也可以通过远程调试定位实机上的bug</li>
<li>若想测试讲师端与学生端的数据互动效果，可以在开发者工具登录一个用户，另一个用户在手机上通过微信最新版本的“切换用户”功能登录小程序</li>
<li>若想测试多个教师或多个学生产生数据的效果，可以通过后台管理网站同时认证讲师或取消讲师认证来实现身份上的同一性。</li>
<li>若想在临时的iPhone测试机上进行远程调试，记得先将该机的测试微信号加入开发者列表，如此方能远程调试成功，测试结束后记得再删除即可。</li>
</ul>
<h5 id="小程序最终界面"><a href="#小程序最终界面" class="headerlink" title="小程序最终界面"></a>小程序最终界面</h5><p>UI设计上大量采用了腾讯云一站式小程序解决方案小程序demo的配色和界面元素。<br>（其实就是没精力去设计UI啦。。。）<br>基本设计思想更偏向WP式的平面风格</p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP2.PNG" alt="WEAPP2"></p>
<p><center>第一版小程序主界面（此时小程序名称还没改）</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP3.PNG" alt="WEAPP3"></p>
<p><center>第一版小程序主界面（无预约时显示的欢迎+提示语）</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP4.JPEG" alt="WEAPP4"></p>
<p><center>第一版小程序课程列表</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP5.JPEG" alt="WEAPP5"></p>
<p><center>第一版小程序讲师端主界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP6.JPEG" alt="WEAPP6"></p>
<p><center>第一版小程序讲师端编辑课程界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP7.JPEG" alt="WEAPP7"></p>
<p><center>第一版小程序“我的”页面</center><br></p>
<h4 id="项目第二版"><a href="#项目第二版" class="headerlink" title="项目第二版"></a>项目第二版</h4><p>项目第二版的迭代原因是十分偶然的。由于<a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;lang=zh_CN&amp;token=&amp;docid=000aee01f98fc0cbd4b6ce43b56c01" target="_blank" rel="noopener">微信官方对于小程序用户登录API的调整</a>影响了wafer1一站式解决方案中的腾讯云小程序SDK以及Node.js服务器端SDK通过信道服务器对用户身份进行认证的正常操作进行，导致了SDK提供的信道全双工通信对于新注册用户不再可用，最终使小程序的大多数功能处于不可用状态。（据悉，wafer2的SDK信道登录方式暂未受到影响，估计是腾讯方面在wafer1逐渐下架的情况下忽视了使用wafer1的老用户，测试不全面而导致这一情况发生）</p>
<p>为了解决这一重大bug，我们团队仔细研读了微信官方的登录API调整公告以及腾讯云SDK文档，最终采用了“添加首次登录用户认证界面+全面弃用信道通信方式并采用原生通信方式全面重写”的改进方案。<strong>值得一提的是，在重写过程中我们着重采用了JavaScript中的异步Promise编程，对小程序前端通信模块、后端服务器MySQL通信模块进行封装重写。在开发过程中，本人收获了更多的JS异步编程经验，并对Promise为代表的异步编程解决方案有了更加深刻的理解</strong></p>
<p>由于第二版着重于bug的修复和代码的重写，并未对UI界面设计做出太多调整，所以此处不再展示小程序主界面截图。若想知道第一版与最新版UI变化为何如此之大，请继续往下阅读，感谢您的理解！</p>
<h5 id="开发难点及笔记-1"><a href="#开发难点及笔记-1" class="headerlink" title="开发难点及笔记"></a>开发难点及笔记</h5><h6 id="微信登录API调整后小程序前端后端相应的修复解决方案"><a href="#微信登录API调整后小程序前端后端相应的修复解决方案" class="headerlink" title="微信登录API调整后小程序前端后端相应的修复解决方案"></a>微信登录API调整后小程序前端后端相应的修复解决方案</h6><p>根据微信官方的说法，若想像之前那样获得完备的用户基本信息:</p>
<blockquote>
<p>必须使用<code>&lt;button&gt;</code>组件，并将<code>open-type</code>指定为<code>getUserInfo</code>类型，用户允许授权后，可获取用户基本信息。</p>
</blockquote>
<p>而另一种使用<code>&lt;open-data&gt;</code>组件展示用户信息的方式，就真的只有展示功能了。。。可能也是我太菜，根本没办法在JS获取到组件内部加载出来的用户信息。</p>
<p>所以就相当于只能让用户点击一次按钮来完成整个用户信息获取的工作。根据我们当初设计的数据库表结构，用户信息，尤其是其唯一标识码openId，在本项目中起到了相当关键的作用，若不能获取这些信息，则根本无法正常使用小程序的各项基本功能，所以我们在小程序的首页设计了一个遮罩层，若未进行用户信息授权的话，用户看见的只有遮罩层上的提示和用户授权登录的按钮。</p>
<p>我们具体的实现结果如下所示:<br>wxml代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;!hasUserInfo&#125;&#125;"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"auth-page"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"auth-page-note"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"../../images/reserve-hl.png"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span>&gt;</span>请允许微信授权登录后\n继续使用小程序<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"auth-page-button"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;canIUse&#125;&#125;"</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> <span class="attr">bindgetuserinfo</span>=<span class="string">"bindGetUserInfo"</span>&gt;</span></span><br><span class="line">                授权登录</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"auth-page-uncomp-note"</span> <span class="attr">wx:else</span>&gt;</span></span><br><span class="line">                不支持授权登录，请升级微信版本</span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>JS代码（index页面内的钩子函数）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bindGetUserInfo: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.detail.userInfo)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userInfo = e.detail.userInfo;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户授权：'</span>, userInfo);</span><br><span class="line"></span><br><span class="line">    wx.setStorageSync(<span class="string">'nickName'</span>,userInfo.nickName);</span><br><span class="line">    wx.setStorageSync(<span class="string">'avatarUrl'</span>, userInfo.avatarUrl);</span><br><span class="line">    auth.showAuthPage(<span class="keyword">this</span>);   </span><br><span class="line"></span><br><span class="line">    wx.showToast(&#123;</span><br><span class="line">      title: <span class="string">"正在登录"</span>,</span><br><span class="line">      icon: <span class="string">"loading"</span>,</span><br><span class="line">      duration: <span class="number">1500</span>,</span><br><span class="line">      mask: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//说实话有点蠢这里，设置了一个硬性的1.5s时间，主要是因为貌似有点bug，</span></span><br><span class="line">    <span class="comment">//我如果设置wx.showToast一直显示，然后在用户信息拿到后再调用wx.hideToast，</span></span><br><span class="line">    <span class="comment">//经常性失灵，很绝望。可能真的是只能在当前页面中的js调用。但是很奇怪的是，wx.stopPullDownRefresh就不用这么干。。。</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用户授权：拒绝'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>JS代码（上面调用的auth所在的auth.js）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> showAuthPage = <span class="function"><span class="params">that</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(wx.getSetting) &#123;</span><br><span class="line">        wx.getSetting(&#123;</span><br><span class="line">            success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> auth = res.authSetting,</span><br><span class="line">                nickName = wx.getStorageSync(<span class="string">'nickName'</span>),</span><br><span class="line">                hasUserInfo;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"授权情况："</span>, auth);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (auth[<span class="string">'scope.userInfo'</span>] &amp;&amp; nickName)</span><br><span class="line">                    hasUserInfo = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    hasUserInfo = <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"授权标记："</span>, hasUserInfo);                    </span><br><span class="line">                that.setData(&#123;</span><br><span class="line">                    hasUserInfo: hasUserInfo</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    showAuthPage: showAuthPage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>感觉上小程序的底层应该也是像Vue、Angular、React那样写了一个有DOM更新之类功能的前端引擎，基本上hasUserInfo更新了之后，那个遮罩层直接就消失了，DOM更新的速度相当快。也有人吐槽小程序的JS风格就像Vue+React。。。</p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP8.PNG" alt="WEAPP8"></p>
<p><center>第二版小程序用户登录授权页面（请忽略那个远程调试用的黑框😂）</center><br></p>
<h6 id="前端通信模块以及后端MySQL通信模块的重写和Promise封装"><a href="#前端通信模块以及后端MySQL通信模块的重写和Promise封装" class="headerlink" title="前端通信模块以及后端MySQL通信模块的重写和Promise封装"></a>前端通信模块以及后端MySQL通信模块的重写和Promise封装</h6><p>有人说，你们不是又重新实现了用户信息获取了吗？为什么还是不能用原来的信道通信方式？而且再不济重新写一个socket类型的通信方式岂不美哉（可以实现全局广播，这样可以及时通知用户是否有数据发生了更改）？</p>
<blockquote>
<p>emmmm，技术菜，只是主要原因之一。（我承认我确实还不会写socket。。。）</p>
</blockquote>
<p>关键是那个腾讯云SDK它就是用<strong>原来的登录方式</strong>（划重点）获取用户信息的啊，现在微信方面彻头彻尾地改了，你不去重写它，还有其他办法吗？</p>
<p>第一步，先别急着把采用信道通信的代码全删了，至少通信时数据的格式你得看看吧。</p>
<p>然后，我确实菜，所以只能在前端通信模块乖乖地上原生wx.request请求了。。。真的，我就觉得这就是AJAX啊。<br>首先还是先写一个简单的<code>post</code>函数，把wx.request定制化封装一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> post = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            url: config.service.testUrl,</span><br><span class="line">            data: obj,</span><br><span class="line">            success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.data.results) &#123;</span><br><span class="line">                    resolve(res.data.results);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reject(res.data.error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">'网络出错'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要用promise对wx.request进行封装呢？理由很简单，依然是我们之前提到的JavaScript的单线程特性，需要使用回调函数<code>callback()</code>对一些可能阻塞整个JS代码执行的操作进行封装，让它们先挂起，让代码先继续执行下去，等需要进行这些操作的时候再回过头来执行——这就是<strong>异步非阻塞的编程模式</strong>。而大部分可以调用的函数都提供了回调的使用方法，以及你自己定义的函数也可以提供回调。</p>
<p>回调作为一种异步编程的解决方法，看起来很美好。但如果在这样的一种场景下你估计就笑不出来了：</p>
<blockquote>
<p>例如，你向后端的一个API请求一个数据。好，数据拿到了，现在你要根据这个数据再去请求后端的另一个API的数据……<br>如此下去，你请求了3个API，OK，你终于拿到了想要的最终数据，然后你还要将这个数据处理一下才能展示到界面里面</p>
</blockquote>
<p>这样的话，你写的代码大概像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                wx.request(&#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">//format your final data.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果再多几次回调函数的嵌套，估计你自己看这代码也差不多要阵亡了。没错，这就是所谓的<strong>回调地狱</strong>。<br>后端与MySQL之类的数据库通信也同理，你输入了一条SQL语句的结果是下一条SQL语句的内容……</p>
<p>那么除了疯狂地筑起一个回调金字塔之外，还有什么别的办法能够解决异步非阻塞编程问题呢？Promise就是其中之一。当然我之前用的async也是一种，但是那个写起来说实话更加别扭，至少Promise允许你用封装函数的方式进行编程，显然比写一些蜜汁有趣的函数数组正常多了。</p>
<p>好了，我之前提到了我用Promise封装了一个<code>post</code>函数，现在我就展示一个使用Promise解决异步问题的实例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initUserInfo = <span class="function">(<span class="params">that</span>) =&gt;</span> &#123;</span><br><span class="line">  wx.login(&#123;</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(res.code) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取用户登录凭证：'</span>, res.code);</span><br><span class="line"></span><br><span class="line">        post(&#123;</span><br><span class="line">          <span class="string">'msgType'</span>: <span class="string">'wxAuth'</span>, </span><br><span class="line">          <span class="string">"code"</span>: res.code</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"收到消息："</span>, res);</span><br><span class="line">          getApp().data.openId = res;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> post(&#123;</span><br><span class="line">            <span class="string">'msgType'</span>: <span class="string">'checkIsTeachAuth'</span>,</span><br><span class="line">            <span class="string">'openId'</span>: getApp().data.openId</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"收到消息："</span>, res);</span><br><span class="line">          <span class="keyword">if</span> (res.isTeachAuth == <span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            getApp().data.isTeachmodeGlobal = <span class="number">2</span>;</span><br><span class="line">            getApp().data.teacherRealName = res.realName;</span><br><span class="line">            getApp().data.teacherAuthId = res.teacherId;</span><br><span class="line">            getApp().data.teachAuthStatus = res.status;</span><br><span class="line"></span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              isTeachMode: <span class="number">2</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> post(&#123;</span><br><span class="line">              <span class="string">'msgType'</span>: <span class="string">'getClassDataTeach'</span>,</span><br><span class="line">              <span class="string">'openId'</span>: getApp().data.openId</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            getApp().data.isTeachmodeGlobal = <span class="number">1</span>;</span><br><span class="line">            getApp().data.teachAuthStatus = res.status;</span><br><span class="line"></span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              isTeachMode: <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> post(&#123;</span><br><span class="line">              <span class="string">'msgType'</span>: <span class="string">'getReservedClass'</span>,</span><br><span class="line">              <span class="string">'openId'</span>: getApp().data.openId</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"收到消息："</span>, res);</span><br><span class="line">          <span class="keyword">if</span> (getApp().data.isTeachmodeGlobal == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              reserveArray: format.timeFormat(res).reverse(),</span><br><span class="line">              emptyNote: <span class="string">''</span>,</span><br><span class="line">              emptyIntro: <span class="string">''</span>,</span><br><span class="line">              emptyUserName: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> (res[<span class="number">0</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">              that.setData(&#123;</span><br><span class="line">                emptyNote: welcomeQuote,</span><br><span class="line">                emptyIntro: userWelcomeIntro,</span><br><span class="line">                emptyUserName: <span class="literal">false</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            wx.stopPullDownRefresh();  </span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            that.setData(&#123;</span><br><span class="line">              classArray: format.timeFormat(res).reverse(),</span><br><span class="line">              emptyNote: <span class="string">''</span>,</span><br><span class="line">              emptyIntro: <span class="string">''</span>,</span><br><span class="line">              emptyUserName: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> (res[<span class="number">0</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">              that.setData(&#123;</span><br><span class="line">                emptyNote: getApp().data.teacherRealName + <span class="string">" 欢迎！"</span>,</span><br><span class="line">                emptyIntro: teacherWelcomeIntro,</span><br><span class="line">                emptyUserName: <span class="literal">false</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            wx.stopPullDownRefresh();</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'发生错误：'</span>, error);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取用户登录态失败：'</span>, res.errMsg);        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是超长无比。。。再联想一下刚才我演示的回调地狱，用回调不知道要套多少层了。。。<br>而且一个<code>post</code>函数可以反复使用，因为其传入的参数只有一个obj，就是发送到后端的json数据包，除此之外其他的操作都可以快速的复用，并且从后端返回的数据结果也可以由Promise传到下一个<code>.then</code>函数中。</p>
<p>除了<code>post</code>之外，我也仿造了信道通信方式，搞了一个<code>emit</code>函数。信道通信方式其实更加地先进，它是将所有的信道监听函数在初始化页面的时候就规定好了，也就是说把所有接收到后端数据之后的<code>success</code>操作都先写好了，之后再到需要向后端服务器发送数据的地方调用<code>emit</code>函数，这样也更加地灵活，发送数据时只管输入数据的格式和内容就OK了。</p>
<p>但是，本项目基本上除了用户在初始化数据或表单时需要将后端返回的数据进行存储和展示操作外，其他的通信操作基本上属于更新数据的范畴，也就是后端返回数据更新成功的结果后，只需调用一下数据刷新函数让服务器将更新好的数据回传即可。既然<code>emit</code>函数的功能如此确定，我也就直接将它封装好了，当然也得用用Promise了，既然都写好了，再多写个回调版本的函数就浪费了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = <span class="function">(<span class="params">obj,that</span>) =&gt;</span> &#123;</span><br><span class="line">    post(obj).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'收到消息：'</span>, res);</span><br><span class="line">        <span class="keyword">if</span> (getApp().data.isTeachModeGlobal == <span class="number">2</span>)</span><br><span class="line">            getApp().data.isTeachDataUpdated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            getApp().data.isStuDataUpdated = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj.msgType == <span class="string">'reserveClass'</span> || obj.msgType == <span class="string">'editClass'</span> </span><br><span class="line">        || obj.msgType == <span class="string">'classDataUpload'</span>) &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">                icon: <span class="string">'success'</span>,</span><br><span class="line">                title: <span class="string">'数据上传成功'</span>,</span><br><span class="line">                duration: <span class="number">3000</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        wx.startPullDownRefresh(&#123;</span><br><span class="line">            success: that.onPullDownRefresh</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发生错误：'</span>, error);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>emit</code>函数实际用起来也就是这样的，多传了一个this指针而已：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">req.emit(&#123;</span><br><span class="line">  <span class="string">'msgType'</span>: <span class="string">'reserveClass'</span>,</span><br><span class="line">  <span class="string">'openId'</span>: getApp().data.openId,</span><br><span class="line">  <span class="string">'nickName'</span>: wx.getStorageSync(<span class="string">'nickName'</span>),</span><br><span class="line">  <span class="string">'classId'</span>: e.currentTarget.dataset.content.id</span><br><span class="line">&#125;,<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>既然后端MySQL通信模块也要Promise封装，那么肯定也是要先定义一个用Promise封装的函数<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> queryProm(sql, params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        pool.getConnection(<span class="function">(<span class="params">error,connection</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(error) &#123; reject(error); <span class="keyword">throw</span> error; &#125; </span><br><span class="line">            connection.query(sql, params, (error, results, fields) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(results) &#123;</span><br><span class="line">                    resolve(results);</span><br><span class="line">                    connection.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，我后来也发现其实大部分的操作其实都只需要一步回调就能解决问题了，所以我也写了一个回调版本的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> query(sql, params, callback) &#123;</span><br><span class="line">    pool.getConnection(<span class="function">(<span class="params">error,connection</span>) =&gt;</span> &#123;</span><br><span class="line">      connection.query(sql, params, (error, results, fields) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">        <span class="keyword">if</span> (results) &#123;</span><br><span class="line">          callback(error, results);</span><br><span class="line">          connection.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后这里也有一个比较模棱两可的经验，就是前端传到后端的json数据包内定义了<code>msgType</code>，可以在传入后端的地址是同一个时，根据msgType消息的类型进行不同的操作。<br>具体操作在后端是怎样分类的，我这里用了比较原始的switch-case语句，但是说实话，这样会造成代码整体的可读性下降。因为消息类型一多，全挤在一层switch里面了，修改和查找都相当困难，这也是我需要改进的地方——代码的合理化、层次化和结构化。</p>
<p>最后用Promise的效果就是这样的（这个就是之前在项目第一版中用async写过的那个操作）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'reserveClass'</span>: </span><br><span class="line">    sql.queryProm(<span class="string">"SELECT * FROM user_reserve WHERE class_id=? AND user_id=?"</span>, </span><br><span class="line">            [req.query.classId, req.query.openId]</span><br><span class="line">        ).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(response[<span class="number">0</span>] == <span class="literal">null</span>) </span><br><span class="line">                <span class="keyword">return</span> sql.queryProm(</span><br><span class="line">                    <span class="string">"INSERT INTO user_reserve (user_id,user_nickname,class_id,submission_date) VALUES(?,?,?,NOW())"</span>,</span><br><span class="line">                    [req.query.openId, req.query.nickName, req.query.classId]</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> sql.queryProm(</span><br><span class="line">                    <span class="string">"UPDATE user_reserve SET status=1 WHERE class_id=? AND user_id=?"</span>,</span><br><span class="line">                    [req.query.classId, req.query.openId]</span><br><span class="line">                );</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            res.send(&#123;<span class="attr">results</span>: response&#125;);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            res.send(&#123;<span class="attr">error</span>: err&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不要啥都写res，想啥呢</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个“想啥呢”的注释是这样的，Express框架本身有一个回传数据功能的对象参数叫res，然后我写函数也习惯把数据本身叫res，这下好了，相当于我用回传的数据去调用他的成员函数send()，这一个数据哪儿来的send()函数啊？当然前端就没有收到任何回传的数据了。我纳闷了很久怎么Promise好好的就不能用了呢，最后登了服务器上去翻了翻log才发现问题，这也充分说明log在debug中的极端重要性。</p>
<p>当然用回调的效果是这样的： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'cancelReserve'</span>:</span><br><span class="line">    sql.query(<span class="string">"UPDATE user_reserve SET status=0 WHERE class_id=? AND user_id=?"</span>,[req.query.classId, req.query.openId], (error, results) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(error) </span><br><span class="line">            res.send(&#123;<span class="attr">error</span>: error&#125;);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            res.send(&#123;<span class="attr">results</span>: results&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>那么既然也在服务器后端弃用了信道通信所在的腾讯云SDK，我也采用了Express原生的路由方式来将请求定位到以上MySQL通信模块所在的文件上。</p>
<h5 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h5><blockquote>
<p>别看我，我就是凑个小节数的，要不然就一个笔记太尴尬了。。。</p>
</blockquote>
<p>本次版本迭代，通过添加用户授权登录界面、从底层用原生请求方式重写前端通信模块和后端MySQL通信模块，并使用Promise进行异步编程封装，基本上修复了信道通信因登录API调整而无法使用，导致整个程序无法正常运行的bug。</p>
<h4 id="项目第三版"><a href="#项目第三版" class="headerlink" title="项目第三版"></a>项目第三版</h4><p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP1.PNG" alt="WEAPP1"></p>
<p><center>小程序第三版主界面，更多预览请直接打开小程序或阅读本文后续内容</center><br></p>
<p>项目第三版的迭代原因是需求方提议加入普通学生用户端也能够发起一对一辅导预约，然后讲师能够对此进行接单的“辅导预约”功能。<br>我们开发方也趁着本次迭代的机会，对小程序的前端界面UI进行了大范围的重写，从而能够彻底弃用原先大范围采用腾讯云一站式小程序解决方案小程序demo的配色和界面元素的旧UI。</p>
<p><strong>在此特别感谢Jason Gao同学以及他的“有通知”小程序对本项目UI重写提供的设计参考和技术支持！</strong></p>
<p>在新UI的开发过程中的技术难点在于：</p>
<ol>
<li>取消了微信小程序的顶部、底部菜单栏后，小程序界面对于不同尺寸以及刘海屏手机的适配；</li>
<li>取消了底部菜单栏后，自行开发的底部菜单栏的路由结构问题；</li>
<li>取消了顶部菜单栏后，下拉刷新、返回导航、页面标题等顶部菜单栏功能不再实用的情况下的自主开发。</li>
<li>tab标签式导航栏的实现</li>
</ol>
<p>同时，我们也修复了众多之前两个版本未发现的、以及在本版本开发过程中遇到的逻辑功能上的bug，例如：</p>
<ol>
<li>预约时间相对于当前时间已经过期的未采取过期处理；</li>
<li>未对辅导预约进行一对一绑定而造成的多个讲师抢单重复预约的情况；</li>
<li>对于人数上限、备注等留空项目的前端数据处理不当；</li>
<li>iOS系统下“我的页面”用户头像被背景图案覆盖的问题；</li>
<li>还有其他的一些细节小bug；</li>
</ol>
<h5 id="开发难点及笔记-2"><a href="#开发难点及笔记-2" class="headerlink" title="开发难点及笔记"></a>开发难点及笔记</h5><p>在谈UI开发之前，我首先得回答这个问题：为什么要隐藏顶部菜单栏以及底部菜单栏呢？</p>
<p>理由有两个：</p>
<ul>
<li>功能上的需要：主要是微信小程序自带的底部菜单栏定制性奇差，必须得每一个菜单项对应的路径、图标、颜色、文字，乃至菜单项的数量，全部都在<code>app.json</code>里写死了，而且样式清一色都是死板的文字/图标/文字+图标，无法进行更高级别的个性化定制。就像本项目这样<strong>加一个高度明显超出菜单栏本身的大大的加号按钮</strong>，或者加一点其他的特殊样式，用微信小程序自带的底部菜单栏都是无法实现的。同理，微信小程序自带的顶部菜单栏同样也无法像本项目这样<strong>放置一个可点击的刷新按钮</strong>。</li>
<li>设计上的需要：从本文中的小程序界面效果图可以看出，这种底色完全一致的、通透的视觉效果，明显区别于直接采用微信小程序自带方案的其他大多数小程序的界面，是十分夺人眼球的设计（虽然直接采用微信小程序自带方案也可以做得相当美观）。</li>
</ul>
<h6 id="UI难点之一：屏幕尺寸适配"><a href="#UI难点之一：屏幕尺寸适配" class="headerlink" title="UI难点之一：屏幕尺寸适配"></a>UI难点之一：屏幕尺寸适配</h6><p><strong>微信小程序事实上就是一种webview套壳应用的变体</strong>，这个是众所周知的事情了。所以不难联想到当使用微信小程序自带的顶部菜单栏时，小程序的wxml界面自上而下渲染的<strong>起点</strong>，应当是在顶部菜单栏的下方的，就像一般的带标题栏的安卓webview页面，都是顶部的元素帮助撑起了手机系统顶部的状态栏以及顶部的菜单栏在内的一个相当大的高度。<br>如果隐藏了顶部菜单栏的话，就会出现wxml界面直接从状态栏下方开始渲染的情况，而且一般状态栏都是最顶层的，也就是说状态栏会遮挡一部分wxml内容。。。大概像下面这样：</p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP9.PNG" alt="WEAPP9"></p>
<p><center>在iPhone X上有刘海的话就更加尴尬了。。。</center><br></p>
<p>所以需要的就是将这一部分的位置空出来，尤其是对iPhone X的刘海要额外进行适配（后来在开发者工具中的测试我们也发现了iPhone 4/iPhone 5这一类小尺寸屏幕的手机也需要额外适配）。所以我们的思路就是动态定义包裹所有其他元素的<code>&lt;view class=&quot;root&quot;&gt;</code>的<code>padding-top</code>wxss属性。尽管wxss无法使用JS进行动态更改，wxml还是能用JS进行动态更改的。所以就想出了动态定义<code>class</code>属性的内容就OK了，代码如下——<br>wxml代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"root &#123;&#123;isIpx?'root-ipx':''&#125;&#125; &#123;&#123;isIp4?'root-ip4':''&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>JS代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">wx.getSystemInfo(&#123;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.model == <span class="string">'iPhone X'</span>)&#123;</span><br><span class="line">            getApp().data.isIpx = <span class="literal">true</span>;</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">                isIpx: getApp().data.isIpx</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(res.model == <span class="string">'iPhone 5'</span> || res.model == <span class="string">'iPhone 4'</span>)&#123;</span><br><span class="line">            getApp().data.isIp4 = <span class="literal">true</span>;</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">                isIp4: getApp().data.isIp4</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>wxss代码：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.root-ip4</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">30</span>rpx; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.root-ipx</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">60</span>rpx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在之后的测试中发现，一旦预约课程的表单变长，可以滚动起来了以后，状态栏底下会出现本来应该被遮罩了的表单。。这是因为<code>padding-top</code>只是把顶部元素下移了，状态栏本身是透明的，所以肯定无法遮罩滚动到顶部的表单。解决方法和上面是一样的，自己再定义一个<code>&lt;view&gt;</code>元素，用来遮挡状态栏底部的其他元素就OK了，同样要对特殊尺寸的屏幕做适配，此处就不再赘述了。</p>
<h6 id="UI难点之二：自行开发的底部菜单栏的路由结构"><a href="#UI难点之二：自行开发的底部菜单栏的路由结构" class="headerlink" title="UI难点之二：自行开发的底部菜单栏的路由结构"></a>UI难点之二：自行开发的底部菜单栏的路由结构</h6><p>为什么要如此强调路由结构呢？因为你需要知道你当前用底部菜单栏打开的页面是哪一个。否则底部菜单栏如何将当前打开页面对应的按钮进行高亮或者其他处理，来对用户形成一种辅助的标识呢？我们在这里使用了一个<strong>相当讨巧的办法</strong>来解决这个问题：</p>
<p>我们并不删除底部菜单栏在<code>app.json</code>中的代码使之彻底消失，只是通过微信小程序API函数<code>wx.hideTabBar</code>对其进行隐藏，这样其基本的路由结构依然存在，无需另外写一个公共的路由代码。页面跳转可以使用<code>wx.switchTab</code>。然后由于自定义的底部菜单栏是重复出现在页面上的，准确来说应该是首页和“我的”页面上，所以我们采用了微信小程序的模板类型元素<code>&lt;template&gt;</code>来进行代码的复用：<br>wxml代码的写法是：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"tabbar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabbar-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabbar-index"</span> <span class="attr">bindtap</span>=<span class="string">"tabbarRoute"</span> <span class="attr">data-index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;indexActive?'/images/index-hl.png':'/images/index.png'&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"color: &#123;&#123;indexActive?'#17abe3':'#bfbfbf'&#125;&#125;"</span>&gt;</span></span><br><span class="line">        首页</span><br><span class="line">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabbar-reserve"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"/images/new-hl.png"</span> <span class="attr">bindtap</span>=<span class="string">"tabbarRoute"</span> <span class="attr">data-index</span>=<span class="string">"1"</span> &gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"tabbar-user"</span> <span class="attr">bindtap</span>=<span class="string">"tabbarRoute"</span> <span class="attr">data-index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;userpageActive?'/images/user-hl.png':'/images/user.png'&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"color: &#123;&#123;userpageActive?'#17abe3':'#bfbfbf'&#125;&#125;"</span>&gt;</span></span><br><span class="line">        我的</span><br><span class="line">      <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在对应的页面中引用的方法也很简单<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"/template/tabbar"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"tabbar"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;...tabStatus&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，三点运算符表示传进<code>tabStatus</code>的全部子成员（这个<code>tabStatus</code>有两个成员：<code>indexActive</code>和<code>userpageActive</code>），也就意味着上面代码块里的<code>&lt;template&gt;</code>中的所有<code>indexActive</code>和<code>userpageActive</code>不用再写成<code>tabStatus.indexActive</code>和<code>tabStatus.userpageActive</code>了，很方便吧，这可是ES6的特性哦！<br>wxss的代码也贴一下，这样也可以直接套用样式：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.tabbar-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90</span>rpx;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">35</span>rpx;</span><br><span class="line">  <span class="attribute">border-top</span>: .<span class="number">5px</span> solid <span class="number">#cccccc</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">256</span>,<span class="number">256</span>,<span class="number">256</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabbar-wrap</span> <span class="selector-tag">view</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabbar-wrap</span> <span class="selector-class">.tabbar-reserve</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>:fixed;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">30</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabbar-wrap</span> <span class="selector-tag">view</span> <span class="selector-tag">image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60</span>rpx;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabbar-wrap</span> <span class="selector-class">.tabbar-reserve</span> <span class="selector-tag">image</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">115</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">115</span>rpx;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;  </span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabbar-wrap</span> <span class="selector-tag">view</span> <span class="selector-tag">view</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">1</span>rpx;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上操作的教程来源是<a href="https://blog.csdn.net/w10322331/article/details/80351713" target="_blank" rel="noopener">这里</a>。</p>
<h6 id="UI难点之三：重写返回导航、页面标题和刷新组件"><a href="#UI难点之三：重写返回导航、页面标题和刷新组件" class="headerlink" title="UI难点之三：重写返回导航、页面标题和刷新组件"></a>UI难点之三：重写返回导航、页面标题和刷新组件</h6><p>既然隐藏了顶部菜单栏，可以说也相当于在打开新页面时也失去了微信小程序自动生成的标题和返回按钮，然后下拉刷新也别扭了很多（尤其是在iPhone X上，你下拉刷新的时候根本看不到那个刷新动画。。。），这就意味着以上功能全部都得自主开发。</p>
<p>我的解决方案也异常简单，返回导航直接使用微信小程序的API函数<code>wx.navigateBack</code>，刷新也不过是在图标上绑定钩子函数，这里的主要难点在于<strong>刷新动画的协调性</strong>。<br>具体怎么说呢？wxss本质上就是CSS，刷新动画的一般实现都是一个圆形刷新图标的旋转，而这个旋转一般都是CSS的效果。但是若像本项目一样使用带箭头的圆环，则会出现一个很尴尬的情况：<br>当你正在“加载数据”这一状态时，圆环是不停旋转的，而当“数据加载结束”时，圆环需要处于一个静止的状态。若将静止状态设置为一个固定的图片，例如说刷新图标的箭头处于图标的正12点方向，则你会发现，”加载数据”这一状态结束时，箭头并不一定处于正12点，而在切换到“数据加载结束”这一状态时，箭头突然就跳到了正12点方向。</p>
<p>可以先看看“有通知”小程序的刷新动画实现方法，基本上就是点击刷新后固定地转一圈，这样既避免了上述尴尬的情况，也可以让用户体验到类似于“转了一圈就加载了”的“快速加载”的观感。</p>
<p>那么我们是如何实现的呢？可以说是一次很成功的尝试吧：让“数据加载结束”这一静止状态不再是一张固定的图片，而是在下一次加载时箭头直接从之前停下的方向继续开始转动！这样给用户的体验就不再是十分突兀的，反而有一种很自然自然的流畅感和美感。</p>
<p>实现方法也很简单，设定好不同状态下的CSS属性即可，只不过需要JS在与后端通信的加载过程中向wxml里刷新图标的<code>style=&quot;&quot;</code>传入不同的变量，以启用或关闭不同的动画。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.line</span> <span class="selector-class">.title-wrap</span> <span class="selector-class">.refresh-button</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">45</span>rpx <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">90</span>rpx;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10</span>rpx;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">15</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#6d6d72</span>;</span><br><span class="line">  <span class="attribute">animation</span>: spin <span class="number">800ms</span> infinite linear;  </span><br><span class="line">  <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.line</span> <span class="selector-class">.title-wrap</span> <span class="selector-class">.refresh-button</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> spin &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">60%</span> <span class="number">55%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: <span class="number">60%</span> <span class="number">55%</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">60%</span> <span class="number">55%</span>;  </span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: <span class="number">60%</span> <span class="number">55%</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个<code>animation-play-state</code>相当关键，就是这一属性支持了我们的刷新开始和结束的自然切换。</p>
<p>哦对了，貌似还有页面标题没讲，这个其实就是自己添加标题写在相应的位置，如果需要动态标题则往wxml中添加变量。注意给返回、刷新之类的按钮留好位置即可。</p>
<h6 id="UI难点之四：tab标签式导航栏的实现"><a href="#UI难点之四：tab标签式导航栏的实现" class="headerlink" title="UI难点之四：tab标签式导航栏的实现"></a>UI难点之四：tab标签式导航栏的实现</h6><p>这个说实话网络上教程相当多，但是这里仍然有一些亮点，例如在高亮标签下的“下划线”。这并不是简单的用CSS的下划线属性实现的，而是使用了CSS的伪类概念。说实话，在后来其他项目的开发过程中，我才真正开始理解并有意识地使用起了伪类，给某一页面元素的正上方或正下方添加一些附属元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tabbar标签式导航栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;navArrayStu&#125;&#125;"</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"item &#123;&#123;currentNavTab==index?'active':''&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"unique"</span> <span class="attr">bindtap</span>=<span class="string">"bindNavbarTap"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;currentNavTab==0&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当currentNavTab==0时显示这里的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;currentNavTab==1&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当currentNavTab==1时显示这里的内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bindNavbarTap(e) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    currentNavTab: e.currentTarget.dataset.index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40</span>rpx;</span><br><span class="line">  <span class="attribute">font-weight</span>: lighter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-class">.item</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类的使用 */</span></span><br><span class="line"><span class="selector-class">.navbar</span> <span class="selector-class">.item</span><span class="selector-class">.active</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5</span>rpx;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#6d6d72</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="BUG解决之一：预约时间相对于当前时间已经过期的未采取过期处理"><a href="#BUG解决之一：预约时间相对于当前时间已经过期的未采取过期处理" class="headerlink" title="BUG解决之一：预约时间相对于当前时间已经过期的未采取过期处理"></a>BUG解决之一：预约时间相对于当前时间已经过期的未采取过期处理</h6><p>过期处理说实话确实是个败笔，因为这个东西本来应该是后端完成的东西，我却非常不厚道的在小程序里面加入了这个功能（不是在批评某些“大前端”思想，但是这个确实后端来做会更好一点，毕竟数据量一大还不如后端处理好了再发给前端，某些过期数据的体积也可以适当压缩一下，况且<strong>我到现在都还没做分页</strong>，感觉药丸。。。）。而且这个过期处理确实挺重要的，在这种预约类小程序里面，所以我也在寻找更好的解决方案，希望（如果有坚持读到这里的）大佬能够联系我提供一些建议，不胜感激！</p>
<p>我的想法是一拿到数据就交给某个工具函数去处理数据，处理完之后再返回数据。这里我直接把过期处理添加到了时间处理函数里面，具体工具函数如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curDate= utils.formatTime(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="keyword">var</span> curDateFull = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeFormat = <span class="function">(<span class="params">str, contentType</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (contentType == <span class="string">'class'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> start = str[i].class_timestart;</span><br><span class="line">      <span class="keyword">var</span> end = str[i].class_timend;</span><br><span class="line">      <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(str[i].class_date.slice(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">var</span> itemDate = str[i].class_date;      </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType == <span class="string">'course'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> start = str[i].course_timestart;</span><br><span class="line">      <span class="keyword">var</span> end = str[i].course_timend;</span><br><span class="line">      <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(str[i].course_date.slice(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">var</span> itemDate = str[i].course_date;      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> curTime = curDateFull.toLocaleString(<span class="string">'chinese'</span>, &#123; <span class="attr">hour12</span>: <span class="literal">false</span> &#125;).slice(<span class="number">10</span>, <span class="number">18</span>).replace(<span class="regexp">/:/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">var</span> itemTime = start.replace(<span class="regexp">/:/g</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期处理在这儿⬇️</span></span><br><span class="line">    <span class="comment">// 如果该记录的日期本身就小于当前的日期，一定过期</span></span><br><span class="line">    <span class="comment">// 如果该记录的日期与当前日期相同，但时间比当前时间要早，也一定过期</span></span><br><span class="line">    <span class="keyword">if</span>((itemDate &lt; curDate) || ((itemDate == curDate) &amp;&amp; (curTime &gt; itemTime)) )&#123;</span><br><span class="line">      str[i].overtime = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      str[i].overtime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    date = date.getFullYear() + <span class="string">"年"</span> +</span><br><span class="line">      (<span class="built_in">parseInt</span>(date.getMonth()) + <span class="number">1</span>).toString() + <span class="string">"月"</span> +</span><br><span class="line">      date.getDate() + <span class="string">"日"</span>;</span><br><span class="line">    start = start.slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start.slice(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">"0"</span>) &#123;</span><br><span class="line">      start = start.slice(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    end = end.slice(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (end.slice(<span class="number">0</span>, <span class="number">1</span>) == <span class="string">"0"</span>) &#123;</span><br><span class="line">      end = end.slice(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contentType == <span class="string">'class'</span>) &#123;</span><br><span class="line">      str[i].class_date = date;</span><br><span class="line">      str[i].class_timestart = start;</span><br><span class="line">      str[i].class_timend = end</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType == <span class="string">'course'</span>) &#123;</span><br><span class="line">      str[i].course_date = date;</span><br><span class="line">      str[i].course_timestart = start;</span><br><span class="line">      str[i].course_timend = end</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"时间处理后："</span>, str);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="BUG解决之二：未对辅导预约进行一对一绑定而造成的多个讲师抢单重复预约的情况"><a href="#BUG解决之二：未对辅导预约进行一对一绑定而造成的多个讲师抢单重复预约的情况" class="headerlink" title="BUG解决之二：未对辅导预约进行一对一绑定而造成的多个讲师抢单重复预约的情况"></a>BUG解决之二：未对辅导预约进行一对一绑定而造成的多个讲师抢单重复预约的情况</h6><p>“辅导预约”这个功能事实上也就是用户“课程预约”功能的一个翻转：讲师自由发布课程，多个用户预约一个讲师的课程，人数上限可以有也可以不设置。反之，用户自由发布辅导需求，多个讲师预约一个用户的课程，但是是一对一的课程，所以人数上限其实是1。但我这里没有再使用人数上限的功能了，而是采用了一个很清奇的绑定思路：多表左联合查询。</p>
<p>这个说实话也是个败笔😂（没错，包括上面那个在内，你在本文看到的所有bug解决的思路，都是些让你觉得很滑稽的解决方式，因为我当时是真的没办法快速找到一些最佳实践的。。。）<br>正常情况下的思路应该是要去维护一个新的数据库字段，就是“是否已经有讲师预约”这样的一个标志字段。<br>但是我这里的处理思路就很清奇，既然已经被讲师预约了的话，那是不是可以让用户的预约数据库表和讲师的接单数据库表进行一个左联合查询，然后如果某个字段联合查询后查询不到讲师的信息（例如昵称nickname之类的）就可以认为是未被讲师接单呢？反之是不是就可以被认为是已经被接单呢？<br>这个清奇的思路事实上是很差劲的，因为这个涉及到一个查询效率的问题，联合查询总的来说肯定要比单表查询要慢很多，数据一多肯定影响性能，而且这样返回前台数据不可避免地泄露了讲师的信息。</p>
<p>当然，还是那句老话，安全起见，后端数据库表结构以及相应的SQL查询语句我是不可能公开的。所以这里就只有描述，没有代码了。</p>
<h6 id="BUG解决之三：对于人数上限、备注等留空项目的前端数据处理不当"><a href="#BUG解决之三：对于人数上限、备注等留空项目的前端数据处理不当" class="headerlink" title="BUG解决之三：对于人数上限、备注等留空项目的前端数据处理不当"></a>BUG解决之三：对于人数上限、备注等留空项目的前端数据处理不当</h6><p>这是个相当玄学的问题，什么叫“处理不当”呢？这涉及到用户体验与数据库管理之间的矛盾。用户当然希望这样的功能实现：在填写的时候，“人数上限”一栏留空，就代表人数上限为无上限，填入数字再表示有一个确定的上限，“备注”留空，就代表没有备注，填入备注就代表有一段备注。但是数据库管理的时候，一个字段的格式一般是固定的，我不可能为了存储“无上限”这一信息就让一个人数上限的字段同时支持整型数和字符或者别的什么，所以我只能无奈地让数字0代表无上限。同时，备注也可以存储为一个“NULL”来代表无备注。但是问题来了，当上传到后端时，前端至少需要对数据做一个预处理：把人数上限从<code>undefined</code>改成0，把备注从<code>undefined</code>改成NULL。我当时就考虑到这里，但是后来才发现：等等，那后端返回到前端呢？不是也得再经历一次相反的转换吗？</p>
<p>大概就是这样一个逻辑：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (classItem.student_limit == <span class="string">'0'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        studentLimit: <span class="string">'无上限'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        studentLimit: classItem.student_limit</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (classItem.student_sum == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        studentSum: <span class="string">'0'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        studentSum: classItem.student_sum</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (classItem.class_intro == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    classItem.class_intro = <span class="string">"无"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="BUG解决之四：iOS系统下“我的页面”用户头像被背景图案覆盖的问题"><a href="#BUG解决之四：iOS系统下“我的页面”用户头像被背景图案覆盖的问题" class="headerlink" title="BUG解决之四：iOS系统下“我的页面”用户头像被背景图案覆盖的问题"></a>BUG解决之四：iOS系统下“我的页面”用户头像被背景图案覆盖的问题</h6><p>这个确实是个意想不到的BUG，在正式上线之后才发现Safari浏览器的渲染引擎存在着这样的bug：当一个具有<code>transform</code>的CSS属性的元素作为背景，而另外一个图片元素在其上方时，将不能够通过<code>z-index</code>属性来控制它们的层级关系。</p>
<p>之后的解决方案是从网上搜索得出的<strong>“以毒攻毒”法</strong>。是的，你没有看错，这个方法就是用<code>transform</code>来解决<code>transform</code>带来的问题的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.avatar-img</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">50</span>rpx auto <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#bfbfbf</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">100</span>rpx) <span class="comment">/* 这个就是解决办法，“以毒攻毒”，简单粗暴 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.colored-top</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">35</span>rpx;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#17abe3</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">8deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="其他小BUG"><a href="#其他小BUG" class="headerlink" title="其他小BUG"></a>其他小BUG</h6><p>这里将会根据项目当前进度，及时更新一些其他的小BUG以及处理方式，也就相当于一些后续了~</p>
<h5 id="小程序最终界面-1"><a href="#小程序最终界面-1" class="headerlink" title="小程序最终界面"></a>小程序最终界面</h5><p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP1.PNG" alt="WEAPP1"></p>
<p><center>小程序第三版主界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP10.jpeg" alt="WEAPP1"></p>
<p><center>用户课程预约界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP11.jpeg" alt="WEAPP1"></p>
<p><center>用户辅导预约界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP12.jpeg" alt="WEAPP1"></p>
<p><center>讲师辅导接单界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP13.jpeg" alt="WEAPP1"></p>
<p><center>讲师辅导接单界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP14.jpeg" alt="WEAPP1"></p>
<p><center>讲师发布课程界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP15.jpeg" alt="WEAPP1"></p>
<p><center>“我的”界面</center><br></p>
<p><img src="/2018/06/28/Notes-About-Recent-Projects-3/WEAPP16.jpeg" alt="WEAPP1"></p>
<p><center>“关于”界面</center><br></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><blockquote>
<p>先。。。先容我吐槽一下吧。<br>讲了挺多的，确实，一看发现上千行了😂（至少在markdown里面是这样，1.3k），我打算以后有机会的话拆成两篇文章发布。<br>写的时间跨度一个月吧，因为各种事情，写写停停，甚至在某几次提笔重新开始继续写下去的时候，都发现自己都不知道之前到底写了什么，现在该写什么，写的初心是什么。都快被各种事情给搞忘了。<br>所以说，要想系统性的总结一个东西，很难。<br>况且我这个小程序至少前端代码是必须要放到GitHub上去的，要想再系统性地整理并分享一个东西，更难。</p>
</blockquote>
<p>首要的，我还是非常感谢明导和郑导、感谢搭档王云程同学（@fafnir）、感谢提供过帮助的高亦非同学（Jason Gao）以及感谢计通学院学生讲师团，给予了我这次项目实战的宝贵机会。如果没有这次实战机会的话，估计我也很难得出如此系统的经验，并写出内容如此（冗长而）丰富的文章了吧。这是一次从零开始、至少是从需求开始的一次系统性的开发，虽然过程不免因为个人水平仍处于成长期、个人其他事务的干扰等各种原因有着种种波折起伏，但是所有的过程都是在从宏观到微观、从代码开发到客户沟通再到界面设计，几乎是全方位地锻炼我的各种能力。</p>
<p>所以，再次感谢在开发过程中给予了我各种帮助和指导的所有人，谢谢大家！</p>
<blockquote>
<p>最后，这是本站的第七篇正式发文，感谢阅读。<br>如有意见和建议，欢迎通过首页的联系方式联系作者。<br>本文参考资料均来源于网络，作者保留相关权利，转载请注明出处。</p>
</blockquote>
]]></content>
      <tags>
        <tag>experience</tag>
      </tags>
  </entry>
</search>
